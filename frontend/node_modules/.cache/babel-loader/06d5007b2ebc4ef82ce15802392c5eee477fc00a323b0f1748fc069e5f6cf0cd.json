{"ast":null,"code":"/**\n * @file Helper module for audio processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/audio\n */\n\nimport { getFile } from './hub.js';\nimport { rfftfreq } from './maths.js';\n\n/**\n * Helper function to read audio from a path/URL.\n * @param {string|URL} url The path/URL to load the audio from.\n * @param {number} sampling_rate The sampling rate to use when decoding the audio.\n * @returns {Promise<Float32Array>} The decoded audio as a `Float32Array`.\n */\nexport async function read_audio(url, sampling_rate) {\n  if (typeof AudioContext === 'undefined') {\n    // Running in node or an environment without AudioContext\n    throw Error(\"Unable to load audio from path/URL since `AudioContext` is not available in your environment. \" + \"Instead, audio data should be passed directly to the pipeline/processor. \" + \"For more information and some example code, see https://huggingface.co/docs/transformers.js/tutorials/node-audio-processing.\");\n  }\n  const response = await (await getFile(url)).arrayBuffer();\n  const audioCTX = new AudioContext({\n    sampleRate: sampling_rate\n  });\n  if (typeof sampling_rate === 'undefined') {\n    console.warn(`No sampling rate provided, using default of ${audioCTX.sampleRate}Hz.`);\n  }\n  const decoded = await audioCTX.decodeAudioData(response);\n  let audio;\n\n  // We now replicate HuggingFace's `ffmpeg_read` method:\n  if (decoded.numberOfChannels === 2) {\n    // When downmixing a stereo audio file to mono using the -ac 1 option in FFmpeg,\n    // the audio signal is summed across both channels to create a single mono channel.\n    // However, if the audio is at full scale (i.e. the highest possible volume level),\n    // the summing of the two channels can cause the audio signal to clip or distort.\n\n    // To prevent this clipping, FFmpeg applies a scaling factor of 1/sqrt(2) (~ 0.707)\n    // to the audio signal before summing the two channels. This scaling factor ensures\n    // that the combined audio signal will not exceed the maximum possible level, even\n    // if both channels are at full scale.\n\n    // After applying this scaling factor, the audio signal from both channels is summed\n    // to create a single mono channel. It's worth noting that this scaling factor is\n    // only applied when downmixing stereo audio to mono using the -ac 1 option in FFmpeg.\n    // If you're using a different downmixing method, or if you're not downmixing the\n    // audio at all, this scaling factor may not be needed.\n    const SCALING_FACTOR = Math.sqrt(2);\n    let left = decoded.getChannelData(0);\n    let right = decoded.getChannelData(1);\n    audio = new Float32Array(left.length);\n    for (let i = 0; i < decoded.length; ++i) {\n      audio[i] = SCALING_FACTOR * (left[i] + right[i]) / 2;\n    }\n  } else {\n    // If the audio is not stereo, we can just use the first channel:\n    audio = decoded.getChannelData(0);\n  }\n  return audio;\n}\n\n/**\n * Creates a frequency bin conversion matrix used to obtain a mel spectrogram.\n * @param {number} sr Sample rate of the audio waveform.\n * @param {number} n_fft Number of frequencies used to compute the spectrogram (should be the same as in `stft`).\n * @param {number} n_mels Number of mel filters to generate.\n * @returns {number[][]} Projection matrix to go from a spectrogram to a mel spectrogram.\n */\nexport function getMelFilters(sr, n_fft) {\n  let n_mels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 128;\n  n_mels = Math.floor(n_mels);\n\n  // Initialize the weights\n  const mel_size = Math.floor(1 + n_fft / 2);\n  const weights = new Array(n_mels);\n\n  // Center freqs of each FFT bin\n  const fftfreqs = rfftfreq(n_fft, 1 / sr);\n\n  // 'Center freqs' of mel bands - uniformly spaced between limits\n  const min_mel = 0.0;\n  const max_mel = 45.245640471924965;\n  const mel_range = max_mel - min_mel;\n  const mel_scale = mel_range / (n_mels + 1);\n\n  // Fill in the linear scale\n  const f_min = 0.0;\n  const f_sp = 200.0 / 3;\n  const freqs = new Array(n_mels + 2);\n\n  // And now the nonlinear scale\n  const min_log_hz = 1000.0; // beginning of log region (Hz)\n  const min_log_mel = (min_log_hz - f_min) / f_sp; // same (Mels)\n  const logstep = Math.log(6.4) / 27.0; // step size for log region\n\n  const ramps = new Array(freqs.length);\n  for (let i = 0; i < freqs.length; ++i) {\n    const mel = i * mel_scale + min_mel;\n    if (mel >= min_log_mel) {\n      freqs[i] = min_log_hz * Math.exp(logstep * (mel - min_log_mel));\n    } else {\n      freqs[i] = f_min + f_sp * mel;\n    }\n    ramps[i] = fftfreqs.map(k => freqs[i] - k);\n  }\n  const fdiffinv = freqs.slice(1).map((v, i) => 1 / (v - freqs[i]));\n  for (let i = 0; i < weights.length; ++i) {\n    weights[i] = new Array(mel_size);\n    const a = fdiffinv[i];\n    const b = fdiffinv[i + 1];\n    const c = ramps[i];\n    const d = ramps[i + 2];\n\n    // Slaney-style mel is scaled to be approx constant energy per channel\n    const enorm = 2.0 / (freqs[i + 2] - freqs[i]);\n    for (let j = 0; j < weights[i].length; ++j) {\n      // lower and upper slopes for all bins\n      const lower = -c[j] * a;\n      const upper = d[j] * b;\n      weights[i][j] = Math.max(0, Math.min(lower, upper)) * enorm;\n    }\n  }\n  return weights;\n}","map":{"version":3,"names":["getFile","rfftfreq","read_audio","url","sampling_rate","AudioContext","Error","response","arrayBuffer","audioCTX","sampleRate","console","warn","decoded","decodeAudioData","audio","numberOfChannels","SCALING_FACTOR","Math","sqrt","left","getChannelData","right","Float32Array","length","i","getMelFilters","sr","n_fft","n_mels","arguments","undefined","floor","mel_size","weights","Array","fftfreqs","min_mel","max_mel","mel_range","mel_scale","f_min","f_sp","freqs","min_log_hz","min_log_mel","logstep","log","ramps","mel","exp","map","k","fdiffinv","slice","v","a","b","c","d","enorm","j","lower","upper","max","min"],"sources":["/Users/phreetech13/Desktop/RealTimeAudioToText/node_modules/@xenova/transformers/src/utils/audio.js"],"sourcesContent":["/**\n * @file Helper module for audio processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/audio\n */\n\nimport {\n    getFile,\n} from './hub.js';\nimport { rfftfreq } from './maths.js';\n\n/**\n * Helper function to read audio from a path/URL.\n * @param {string|URL} url The path/URL to load the audio from.\n * @param {number} sampling_rate The sampling rate to use when decoding the audio.\n * @returns {Promise<Float32Array>} The decoded audio as a `Float32Array`.\n */\nexport async function read_audio(url, sampling_rate) {\n    if (typeof AudioContext === 'undefined') {\n        // Running in node or an environment without AudioContext\n        throw Error(\n            \"Unable to load audio from path/URL since `AudioContext` is not available in your environment. \" +\n            \"Instead, audio data should be passed directly to the pipeline/processor. \" +\n            \"For more information and some example code, see https://huggingface.co/docs/transformers.js/tutorials/node-audio-processing.\"\n        )\n    }\n\n    const response = await (await getFile(url)).arrayBuffer();\n    const audioCTX = new AudioContext({ sampleRate: sampling_rate });\n    if (typeof sampling_rate === 'undefined') {\n        console.warn(`No sampling rate provided, using default of ${audioCTX.sampleRate}Hz.`)\n    }\n    const decoded = await audioCTX.decodeAudioData(response);\n    let audio;\n\n    // We now replicate HuggingFace's `ffmpeg_read` method:\n    if (decoded.numberOfChannels === 2) {\n        // When downmixing a stereo audio file to mono using the -ac 1 option in FFmpeg,\n        // the audio signal is summed across both channels to create a single mono channel.\n        // However, if the audio is at full scale (i.e. the highest possible volume level),\n        // the summing of the two channels can cause the audio signal to clip or distort.\n\n        // To prevent this clipping, FFmpeg applies a scaling factor of 1/sqrt(2) (~ 0.707)\n        // to the audio signal before summing the two channels. This scaling factor ensures\n        // that the combined audio signal will not exceed the maximum possible level, even\n        // if both channels are at full scale.\n\n        // After applying this scaling factor, the audio signal from both channels is summed\n        // to create a single mono channel. It's worth noting that this scaling factor is\n        // only applied when downmixing stereo audio to mono using the -ac 1 option in FFmpeg.\n        // If you're using a different downmixing method, or if you're not downmixing the\n        // audio at all, this scaling factor may not be needed.\n        const SCALING_FACTOR = Math.sqrt(2);\n\n        let left = decoded.getChannelData(0);\n        let right = decoded.getChannelData(1);\n\n        audio = new Float32Array(left.length);\n        for (let i = 0; i < decoded.length; ++i) {\n            audio[i] = SCALING_FACTOR * (left[i] + right[i]) / 2;\n        }\n\n    } else {\n        // If the audio is not stereo, we can just use the first channel:\n        audio = decoded.getChannelData(0);\n    }\n\n    return audio;\n}\n\n/**\n * Creates a frequency bin conversion matrix used to obtain a mel spectrogram.\n * @param {number} sr Sample rate of the audio waveform.\n * @param {number} n_fft Number of frequencies used to compute the spectrogram (should be the same as in `stft`).\n * @param {number} n_mels Number of mel filters to generate.\n * @returns {number[][]} Projection matrix to go from a spectrogram to a mel spectrogram.\n */\nexport function getMelFilters(sr, n_fft, n_mels = 128) {\n    n_mels = Math.floor(n_mels);\n\n    // Initialize the weights\n    const mel_size = Math.floor(1 + n_fft / 2);\n    const weights = new Array(n_mels);\n\n    // Center freqs of each FFT bin\n    const fftfreqs = rfftfreq(n_fft, 1 / sr);\n\n    // 'Center freqs' of mel bands - uniformly spaced between limits\n    const min_mel = 0.0;\n    const max_mel = 45.245640471924965;\n    const mel_range = max_mel - min_mel;\n    const mel_scale = mel_range / (n_mels + 1);\n\n    // Fill in the linear scale\n    const f_min = 0.0;\n    const f_sp = 200.0 / 3;\n    const freqs = new Array(n_mels + 2);\n\n    // And now the nonlinear scale\n    const min_log_hz = 1000.0; // beginning of log region (Hz)\n    const min_log_mel = (min_log_hz - f_min) / f_sp; // same (Mels)\n    const logstep = Math.log(6.4) / 27.0; // step size for log region\n\n    const ramps = new Array(freqs.length);\n    for (let i = 0; i < freqs.length; ++i) {\n        const mel = i * mel_scale + min_mel;\n        if (mel >= min_log_mel) {\n            freqs[i] = min_log_hz * Math.exp(logstep * (mel - min_log_mel));\n        } else {\n            freqs[i] = f_min + f_sp * mel;\n        }\n        ramps[i] = fftfreqs.map(k => freqs[i] - k);\n    }\n\n    const fdiffinv = freqs.slice(1).map((v, i) => 1 / (v - freqs[i]));\n\n    for (let i = 0; i < weights.length; ++i) {\n        weights[i] = new Array(mel_size);\n\n        const a = fdiffinv[i];\n        const b = fdiffinv[i + 1];\n        const c = ramps[i];\n        const d = ramps[i + 2];\n\n        // Slaney-style mel is scaled to be approx constant energy per channel\n        const enorm = 2.0 / (freqs[i + 2] - freqs[i]);\n\n        for (let j = 0; j < weights[i].length; ++j) {\n            // lower and upper slopes for all bins\n            const lower = -c[j] * a;\n            const upper = d[j] * b;\n            weights[i][j] = Math.max(0, Math.min(lower, upper)) * enorm;\n        }\n    }\n\n    return weights;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SACIA,OAAO,QACJ,UAAU;AACjB,SAASC,QAAQ,QAAQ,YAAY;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeC,UAAUA,CAACC,GAAG,EAAEC,aAAa,EAAE;EACjD,IAAI,OAAOC,YAAY,KAAK,WAAW,EAAE;IACrC;IACA,MAAMC,KAAK,CACP,gGAAgG,GAChG,2EAA2E,GAC3E,8HACJ,CAAC;EACL;EAEA,MAAMC,QAAQ,GAAG,MAAM,CAAC,MAAMP,OAAO,CAACG,GAAG,CAAC,EAAEK,WAAW,CAAC,CAAC;EACzD,MAAMC,QAAQ,GAAG,IAAIJ,YAAY,CAAC;IAAEK,UAAU,EAAEN;EAAc,CAAC,CAAC;EAChE,IAAI,OAAOA,aAAa,KAAK,WAAW,EAAE;IACtCO,OAAO,CAACC,IAAI,CAAE,+CAA8CH,QAAQ,CAACC,UAAW,KAAI,CAAC;EACzF;EACA,MAAMG,OAAO,GAAG,MAAMJ,QAAQ,CAACK,eAAe,CAACP,QAAQ,CAAC;EACxD,IAAIQ,KAAK;;EAET;EACA,IAAIF,OAAO,CAACG,gBAAgB,KAAK,CAAC,EAAE;IAChC;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA,MAAMC,cAAc,GAAGC,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC;IAEnC,IAAIC,IAAI,GAAGP,OAAO,CAACQ,cAAc,CAAC,CAAC,CAAC;IACpC,IAAIC,KAAK,GAAGT,OAAO,CAACQ,cAAc,CAAC,CAAC,CAAC;IAErCN,KAAK,GAAG,IAAIQ,YAAY,CAACH,IAAI,CAACI,MAAM,CAAC;IACrC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,OAAO,CAACW,MAAM,EAAE,EAAEC,CAAC,EAAE;MACrCV,KAAK,CAACU,CAAC,CAAC,GAAGR,cAAc,IAAIG,IAAI,CAACK,CAAC,CAAC,GAAGH,KAAK,CAACG,CAAC,CAAC,CAAC,GAAG,CAAC;IACxD;EAEJ,CAAC,MAAM;IACH;IACAV,KAAK,GAAGF,OAAO,CAACQ,cAAc,CAAC,CAAC,CAAC;EACrC;EAEA,OAAON,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASW,aAAaA,CAACC,EAAE,EAAEC,KAAK,EAAgB;EAAA,IAAdC,MAAM,GAAAC,SAAA,CAAAN,MAAA,QAAAM,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,GAAG;EACjDD,MAAM,GAAGX,IAAI,CAACc,KAAK,CAACH,MAAM,CAAC;;EAE3B;EACA,MAAMI,QAAQ,GAAGf,IAAI,CAACc,KAAK,CAAC,CAAC,GAAGJ,KAAK,GAAG,CAAC,CAAC;EAC1C,MAAMM,OAAO,GAAG,IAAIC,KAAK,CAACN,MAAM,CAAC;;EAEjC;EACA,MAAMO,QAAQ,GAAGnC,QAAQ,CAAC2B,KAAK,EAAE,CAAC,GAAGD,EAAE,CAAC;;EAExC;EACA,MAAMU,OAAO,GAAG,GAAG;EACnB,MAAMC,OAAO,GAAG,kBAAkB;EAClC,MAAMC,SAAS,GAAGD,OAAO,GAAGD,OAAO;EACnC,MAAMG,SAAS,GAAGD,SAAS,IAAIV,MAAM,GAAG,CAAC,CAAC;;EAE1C;EACA,MAAMY,KAAK,GAAG,GAAG;EACjB,MAAMC,IAAI,GAAG,KAAK,GAAG,CAAC;EACtB,MAAMC,KAAK,GAAG,IAAIR,KAAK,CAACN,MAAM,GAAG,CAAC,CAAC;;EAEnC;EACA,MAAMe,UAAU,GAAG,MAAM,CAAC,CAAC;EAC3B,MAAMC,WAAW,GAAG,CAACD,UAAU,GAAGH,KAAK,IAAIC,IAAI,CAAC,CAAC;EACjD,MAAMI,OAAO,GAAG5B,IAAI,CAAC6B,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC;;EAEtC,MAAMC,KAAK,GAAG,IAAIb,KAAK,CAACQ,KAAK,CAACnB,MAAM,CAAC;EACrC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,KAAK,CAACnB,MAAM,EAAE,EAAEC,CAAC,EAAE;IACnC,MAAMwB,GAAG,GAAGxB,CAAC,GAAGe,SAAS,GAAGH,OAAO;IACnC,IAAIY,GAAG,IAAIJ,WAAW,EAAE;MACpBF,KAAK,CAAClB,CAAC,CAAC,GAAGmB,UAAU,GAAG1B,IAAI,CAACgC,GAAG,CAACJ,OAAO,IAAIG,GAAG,GAAGJ,WAAW,CAAC,CAAC;IACnE,CAAC,MAAM;MACHF,KAAK,CAAClB,CAAC,CAAC,GAAGgB,KAAK,GAAGC,IAAI,GAAGO,GAAG;IACjC;IACAD,KAAK,CAACvB,CAAC,CAAC,GAAGW,QAAQ,CAACe,GAAG,CAACC,CAAC,IAAIT,KAAK,CAAClB,CAAC,CAAC,GAAG2B,CAAC,CAAC;EAC9C;EAEA,MAAMC,QAAQ,GAAGV,KAAK,CAACW,KAAK,CAAC,CAAC,CAAC,CAACH,GAAG,CAAC,CAACI,CAAC,EAAE9B,CAAC,KAAK,CAAC,IAAI8B,CAAC,GAAGZ,KAAK,CAAClB,CAAC,CAAC,CAAC,CAAC;EAEjE,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,OAAO,CAACV,MAAM,EAAE,EAAEC,CAAC,EAAE;IACrCS,OAAO,CAACT,CAAC,CAAC,GAAG,IAAIU,KAAK,CAACF,QAAQ,CAAC;IAEhC,MAAMuB,CAAC,GAAGH,QAAQ,CAAC5B,CAAC,CAAC;IACrB,MAAMgC,CAAC,GAAGJ,QAAQ,CAAC5B,CAAC,GAAG,CAAC,CAAC;IACzB,MAAMiC,CAAC,GAAGV,KAAK,CAACvB,CAAC,CAAC;IAClB,MAAMkC,CAAC,GAAGX,KAAK,CAACvB,CAAC,GAAG,CAAC,CAAC;;IAEtB;IACA,MAAMmC,KAAK,GAAG,GAAG,IAAIjB,KAAK,CAAClB,CAAC,GAAG,CAAC,CAAC,GAAGkB,KAAK,CAAClB,CAAC,CAAC,CAAC;IAE7C,KAAK,IAAIoC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,OAAO,CAACT,CAAC,CAAC,CAACD,MAAM,EAAE,EAAEqC,CAAC,EAAE;MACxC;MACA,MAAMC,KAAK,GAAG,CAACJ,CAAC,CAACG,CAAC,CAAC,GAAGL,CAAC;MACvB,MAAMO,KAAK,GAAGJ,CAAC,CAACE,CAAC,CAAC,GAAGJ,CAAC;MACtBvB,OAAO,CAACT,CAAC,CAAC,CAACoC,CAAC,CAAC,GAAG3C,IAAI,CAAC8C,GAAG,CAAC,CAAC,EAAE9C,IAAI,CAAC+C,GAAG,CAACH,KAAK,EAAEC,KAAK,CAAC,CAAC,GAAGH,KAAK;IAC/D;EACJ;EAEA,OAAO1B,OAAO;AAClB"},"metadata":{},"sourceType":"module","externalDependencies":[]}