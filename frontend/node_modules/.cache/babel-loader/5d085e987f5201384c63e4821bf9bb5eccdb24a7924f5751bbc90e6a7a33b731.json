{"ast":null,"code":"/**\n * @file Classes, functions, and utilities for generation.\n * \n * @todo Describe how to create a custom `GenerationConfig`.\n * \n * @module utils/generation\n */\nimport { Tensor } from './tensor.js';\nimport { Callable, exists } from './core.js';\nimport { max, softmax, log_softmax, getTopItems } from './maths.js';\n\n/**\n * A class representing a list of logits processors. A logits processor is a function that modifies the logits\n * output of a language model. This class provides methods for adding new processors and applying all processors to a\n * batch of logits.\n *\n * @extends Callable\n */\nexport class LogitsProcessorList extends Callable {\n  /**\n   * Constructs a new instance of `LogitsProcessorList`.\n   */\n  constructor() {\n    super();\n    this.processors = [];\n  }\n\n  /**\n   * Adds a new logits processor to the list.\n   *\n   * @param {LogitsProcessor} item The logits processor function to add.\n   */\n  push(item) {\n    this.processors.push(item);\n  }\n\n  /**\n   * Adds multiple logits processors to the list.\n   *\n   * @param {LogitsProcessor[]} items The logits processor functions to add.\n   */\n  extend(items) {\n    this.processors.push(...items);\n  }\n\n  /**\n   * Applies all logits processors in the list to a batch of logits, modifying them in-place.\n   *\n   * @param {number[]} input_ids The input IDs for the language model.\n   * @param {number[][]} batchedLogits A 2D array of logits, where each row corresponds to a single\n   *                                                input sequence in the batch.\n   */\n  _call(input_ids, batchedLogits) {\n    // NOTE: This is different from the Python code, since vanilla JS does not support vectorized operations. \n    // As a result, we apply each processor to each item in the batch.\n    for (let logits of batchedLogits) {\n      // Modifies logits inplace\n      this.processors.forEach(func => func(input_ids, logits));\n    }\n  }\n  [Symbol.iterator]() {\n    return this.processors.values();\n  }\n}\n\n/**\n * Base class for processing logits.\n * @extends Callable\n */\nexport class LogitsProcessor extends Callable {\n  /**\n   * Apply the processor to the input logits.\n   *\n   * @abstract\n   * @param {Array} input_ids The input ids.\n   * @param {Tensor} logits The logits to process.\n   * @throws {Error} Throws an error if `_call` is not implemented in the subclass.\n   */\n  _call(input_ids, logits) {\n    throw Error(\"`_call` should be implemented in a subclass\");\n  }\n}\n\n/**\n * A logits processor that forces a specific token to be generated by the decoder.\n * \n * @extends LogitsProcessor\n */\nexport class ForceTokensLogitsProcessor extends LogitsProcessor {\n  /**\n   * Constructs a new instance of `ForceTokensLogitsProcessor`.\n   * \n   * @param {Array} forced_decoder_ids The ids of tokens that should be forced.\n   */\n  constructor(forced_decoder_ids) {\n    super();\n    this.force_token_map = Object.fromEntries(forced_decoder_ids ?? []);\n  }\n\n  /**\n   * Apply the processor to the input logits.\n   *\n   * @param {Array} input_ids The input ids.\n   * @param {any} logits The logits to process.\n   * @returns {Array} The processed logits.\n   */\n  _call(input_ids, logits) {\n    let map = this.force_token_map[input_ids.length];\n    if (exists(map)) {\n      // There exists a mapping\n      logits.data.fill(-Infinity);\n      logits.data[map] = 0;\n    }\n    return logits;\n  }\n}\n\n/**\n * A LogitsProcessor that forces a BOS token at the beginning of the generated sequence.\n * @extends LogitsProcessor\n */\nexport class ForcedBOSTokenLogitsProcessor extends LogitsProcessor {\n  /**\n   * Create a ForcedBOSTokenLogitsProcessor.\n   * @param {number} bos_token_id The ID of the beginning-of-sequence token to be forced.\n   */\n  constructor(bos_token_id) {\n    super();\n    this.bos_token_id = bos_token_id;\n  }\n\n  /**\n   * Apply the BOS token forcing to the logits.\n   * @param {Array} input_ids The input IDs.\n   * @param {Object} logits The logits.\n   * @returns {Object} The logits with BOS token forcing.\n   */\n  _call(input_ids, logits) {\n    if (input_ids.length === 1) {\n      logits.data.fill(-Infinity);\n      logits.data[this.bos_token_id] = 0;\n    }\n    return logits;\n  }\n}\n\n/**\n * A logits processor that forces end-of-sequence token probability to 1.\n * \n * @extends LogitsProcessor\n */\nexport class ForcedEOSTokenLogitsProcessor extends LogitsProcessor {\n  /**\n   * Create a ForcedEOSTokenLogitsProcessor.\n   * @param {number} max_length Max length of the sequence.\n   * @param {number|number[]} forced_eos_token_id The ID of the end-of-sequence token to be forced.\n   */\n  constructor(max_length, forced_eos_token_id) {\n    super();\n    this.max_length = max_length;\n    this.forced_eos_token_id = forced_eos_token_id;\n  }\n\n  /**\n   * Apply the processor to input_ids and logits.\n   * \n   * @param {number[]} input_ids The input ids.\n   * @param {any} logits The logits tensor.\n   */\n  _call(input_ids, logits) {\n    // console.log('call ForcedEOSTokenLogitsProcessor')\n    // TODO\n  }\n}\n\n/**\n * A LogitsProcessor that suppresses a list of tokens as soon as the `generate` function starts\n * generating using `begin_index` tokens. This should ensure that the tokens defined by\n * `begin_suppress_tokens` at not sampled at the begining of the generation.\n * @extends LogitsProcessor\n */\nexport class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor {\n  /**\n   * Create a SuppressTokensAtBeginLogitsProcessor.\n   * @param {number[]} begin_suppress_tokens The IDs of the tokens to suppress.\n   * @param {number} begin_index The number of tokens to generate before suppressing tokens.\n   */\n  constructor(begin_suppress_tokens, begin_index) {\n    super();\n    this.begin_suppress_tokens = begin_suppress_tokens;\n    this.begin_index = begin_index;\n  }\n\n  /**\n   * Apply the BOS token forcing to the logits.\n   * @param {Array} input_ids The input IDs.\n   * @param {Object} logits The logits.\n   * @returns {Object} The logits with BOS token forcing.\n   */\n  _call(input_ids, logits) {\n    if (input_ids.length === this.begin_index) {\n      for (let token_id of this.begin_suppress_tokens) {\n        logits.data[token_id] = -Infinity;\n      }\n    }\n    return logits;\n  }\n}\n\n/**\n * A LogitsProcessor that handles adding timestamps to generated text.\n * @extends LogitsProcessor\n */\nexport class WhisperTimeStampLogitsProcessor extends LogitsProcessor {\n  /**\n   * Constructs a new WhisperTimeStampLogitsProcessor.\n   * @param {Object} generate_config The config object passed to the `generate()` method of a transformer model.\n   * @param {number} generate_config.eos_token_id The ID of the end-of-sequence token.\n   * @param {number} generate_config.no_timestamps_token_id The ID of the token used to indicate that a token should not have a timestamp.\n   * @param {number[][]} [generate_config.forced_decoder_ids] An array of two-element arrays representing decoder IDs that are forced to appear in the output. The second element of each array indicates whether the token is a timestamp.\n   * @param {number} [generate_config.max_initial_timestamp_index] The maximum index at which an initial timestamp can appear.\n   */\n  constructor(generate_config) {\n    super();\n    this.eos_token_id = generate_config.eos_token_id;\n    this.no_timestamps_token_id = generate_config.no_timestamps_token_id;\n    this.timestamp_begin = this.no_timestamps_token_id + 1;\n    this.begin_index = (generate_config.forced_decoder_ids || []).length + 2;\n    if (generate_config.forced_decoder_ids.slice(-1)[0][1] === this.no_timestamps_token_id) {\n      this.begin_index -= 1;\n    }\n    this.max_initial_timestamp_index = generate_config.max_initial_timestamp_index;\n  }\n\n  /**\n   * Modify the logits to handle timestamp tokens.\n   * @param {Array} input_ids The input sequence of tokens.\n   * @param {Tensor} logits The logits output by the model.\n   * @returns {Tensor} The modified logits.\n   */\n  _call(input_ids, logits) {\n    // suppress <|notimestamps|> which is handled by without_timestamps\n    logits.data[this.no_timestamps_token_id] = -Infinity;\n    if (input_ids.length === this.begin_index - 1) {\n      logits.data.fill(-Infinity);\n      logits.data[this.timestamp_begin] = 0;\n      return logits;\n    }\n\n    // timestamps have to appear in pairs, except directly before eos_token; mask logits accordingly\n    const seq = input_ids.slice(this.begin_index);\n    const last_was_timestamp = seq.length >= 1 && seq[seq.length - 1] >= this.timestamp_begin;\n    const penultimate_was_timestamp = seq.length < 2 || seq[seq.length - 2] >= this.timestamp_begin;\n    if (last_was_timestamp) {\n      if (penultimate_was_timestamp) {\n        // has to be non-timestamp\n        logits.data.subarray(this.timestamp_begin).fill(-Infinity);\n      } else {\n        // cannot be normal text tokens\n        logits.data.subarray(0, this.eos_token_id).fill(-Infinity);\n      }\n    }\n\n    // apply the `max_initial_timestamp` option\n    if (input_ids.length === this.begin_index && this.max_initial_timestamp_index !== null) {\n      const last_allowed = this.timestamp_begin + this.max_initial_timestamp_index;\n      logits.data.subarray(last_allowed + 1).fill(-Infinity);\n    }\n\n    // if sum of probability over timestamps is above any other token, sample timestamp\n    const logprobs = log_softmax(logits.data);\n    const timestamp_logprob = Math.log(logprobs.subarray(this.timestamp_begin).map(Math.exp).reduce((a, b) => a + b));\n    const max_text_token_logprob = max(logprobs.subarray(0, this.timestamp_begin))[0];\n    if (timestamp_logprob > max_text_token_logprob) {\n      logits.data.subarray(0, this.timestamp_begin).fill(-Infinity);\n    }\n    return logits;\n  }\n}\n\n/**\n * A logits processor that disallows ngrams of a certain size to be repeated.\n * \n * @extends LogitsProcessor\n */\nexport class NoRepeatNGramLogitsProcessor extends LogitsProcessor {\n  /**\n   * Create a NoRepeatNGramLogitsProcessor.\n   * @param {number} no_repeat_ngram_size The no-repeat-ngram size. All ngrams of this size can only occur once.\n   */\n  constructor(no_repeat_ngram_size) {\n    super();\n    this.no_repeat_ngram_size = no_repeat_ngram_size;\n  }\n\n  /**\n   * Generate n-grams from a sequence of token ids.\n   * @param {number[]} prevInputIds List of previous input ids\n   * @returns {Map<string, number[]>} Map of generated n-grams\n   */\n  getNgrams(prevInputIds) {\n    const curLen = prevInputIds.length;\n\n    /**@type {number[][]} */\n    const ngrams = [];\n    for (let j = 0; j < curLen + 1 - this.no_repeat_ngram_size; ++j) {\n      const ngram = [];\n      for (let k = 0; k < this.no_repeat_ngram_size; ++k) {\n        ngram.push(prevInputIds[j + k]);\n      }\n      ngrams.push(ngram);\n    }\n\n    /** @type {Map<string, number[]>} */\n    const generatedNgram = new Map();\n    for (const ngram of ngrams) {\n      const prevNgram = ngram.slice(0, ngram.length - 1);\n      const prevNgramKey = JSON.stringify(prevNgram);\n      const prevNgramValue = generatedNgram.get(prevNgramKey) ?? [];\n      prevNgramValue.push(ngram[ngram.length - 1]);\n      generatedNgram.set(prevNgramKey, prevNgramValue);\n    }\n    return generatedNgram;\n  }\n\n  /**\n   * Generate n-grams from a sequence of token ids.\n   * @param {Map<string, number[]>} bannedNgrams Map of banned n-grams\n   * @param {number[]} prevInputIds List of previous input ids\n   * @returns {number[]} Map of generated n-grams\n   */\n  getGeneratedNgrams(bannedNgrams, prevInputIds) {\n    const ngramIdx = prevInputIds.slice(prevInputIds.length + 1 - this.no_repeat_ngram_size, prevInputIds.length);\n    const banned = bannedNgrams.get(JSON.stringify(ngramIdx)) ?? [];\n    return banned;\n  }\n\n  /**\n   * Calculate banned n-gram tokens\n   * @param {number[]} prevInputIds List of previous input ids\n   * @returns {number[]} Map of generated n-grams\n   */\n  calcBannedNgramTokens(prevInputIds) {\n    const bannedTokens = [];\n    if (prevInputIds.length + 1 < this.no_repeat_ngram_size) {\n      // return no banned tokens if we haven't generated no_repeat_ngram_size tokens yet\n      return bannedTokens;\n    } else {\n      const generatedNgrams = this.getNgrams(prevInputIds);\n      const bannedTokens = this.getGeneratedNgrams(generatedNgrams, prevInputIds);\n      return bannedTokens;\n    }\n  }\n\n  /**\n   * Apply the no-repeat-ngram processor to the logits.\n   * @param {Array} input_ids The input IDs.\n   * @param {Object} logits The logits.\n   * @returns {Object} The logits with no-repeat-ngram processing.\n   */\n  _call(input_ids, logits) {\n    const bannedTokens = this.calcBannedNgramTokens(input_ids);\n    for (const token of bannedTokens) {\n      logits.data[token] = -Infinity;\n    }\n    return logits;\n  }\n}\n\n/**\n * A logits processor that penalises repeated output tokens.\n * \n * @extends LogitsProcessor\n */\nexport class RepetitionPenaltyLogitsProcessor extends LogitsProcessor {\n  /**\n   * Create a RepetitionPenaltyLogitsProcessor.\n   * @param {number} penalty The penalty to apply for repeated tokens.\n   */\n  constructor(penalty) {\n    super();\n    this.penalty = penalty;\n  }\n\n  /**\n   * Apply the repetition penalty to the logits.\n   * @param {Array} input_ids The input IDs.\n   * @param {Object} logits The logits.\n   * @returns {Object} The logits with repetition penalty processing.\n   */\n  _call(input_ids, logits) {\n    // Modify the logits corresponding to each element in `input_ids`.\n    // As a consequence, the logits corresponding to tokens that appear\n    // many times in the output will be penalised more.\n    for (const input_id of input_ids) {\n      if (logits.data[input_id] < 0) {\n        logits.data[input_id] *= this.penalty;\n      } else {\n        logits.data[input_id] /= this.penalty;\n      }\n    }\n    return logits;\n  }\n}\n\n/**\n * Class that holds a configuration for a generation task.\n */\nexport class GenerationConfig {\n  /**\n   * Create a GenerationConfig object\n   * @param {Object} [kwargs={}] The configuration parameters. If not set, the default values are used.\n   * @param {number} [kwargs.max_length=20] The maximum length the generated tokens can have. Corresponds to the length of the input prompt + `max_new_tokens`. Its effect is overridden by `max_new_tokens`, if also set.\n   * @param {number} [kwargs.max_new_tokens=null] The maximum numbers of tokens to generate, ignoring the number of tokens in the prompt.\n   * @param {number} [kwargs.min_length=0] The minimum length of the sequence to be generated. Corresponds to the length of the input prompt + `min_new_tokens`. Its effect is overridden by `min_new_tokens`, if also set.\n   * @param {number} [kwargs.min_new_tokens=null] The minimum numbers of tokens to generate, ignoring the number of tokens in the prompt.\n   * @param {boolean|\"never\"} [kwargs.early_stopping=false] Controls the stopping condition for beam-based methods, like beam-search. It accepts the following values:\n   * - `true`, where the generation stops as soon as there are `num_beams` complete candidates;\n   * - `false`, where an heuristic is applied and the generation stops when is it very unlikely to find better candidates;\n   * - `\"never\"`, where the beam search procedure only stops when there cannot be better candidates (canonical beam search algorithm).\n   * @param {number} [kwargs.max_time=null] The maximum amount of time you allow the computation to run for in seconds. Generation will still finish the current pass after allocated time has been passed.\n   *\n   * @param {boolean} [kwargs.do_sample=false] Whether or not to use sampling; use greedy decoding otherwise.\n   * @param {number} [kwargs.num_beams=1] Number of beams for beam search. 1 means no beam search.\n   * @param {number} [kwargs.num_beam_groups=1] Number of groups to divide `num_beams` into in order to ensure diversity among different groups of beams. See [this paper](https://arxiv.org/pdf/1610.02424.pdf) for more details.\n   * @param {number} [kwargs.penalty_alpha=null] The values balance the model confidence and the degeneration penalty in contrastive search decoding.\n   * @param {boolean} [kwargs.use_cache=true] Whether or not the model should use the past last key/values attentions (if applicable to the model) to speed up decoding.\n   *\n   * @param {number} [kwargs.temperature=1.0] The value used to modulate the next token probabilities.\n   * @param {number} [kwargs.top_k=50] The number of highest probability vocabulary tokens to keep for top-k-filtering.\n   * @param {number} [kwargs.top_p=1.0] If set to float < 1, only the smallest set of most probable tokens with probabilities that add up to `top_p` or higher are kept for generation.\n   * @param {number} [kwargs.typical_p=1.0] Local typicality measures how similar the conditional probability of predicting a target token next is to the expected conditional probability of predicting a random token next, given the partial text already generated. If set to float < 1, the smallest set of the most locally typical tokens with probabilities that add up to `typical_p` or higher are kept for generation. See [this paper](https://arxiv.org/pdf/2202.00666.pdf) for more details.\n   * @param {number} [kwargs.epsilon_cutoff=0.0] If set to float strictly between 0 and 1, only tokens with a conditional probability greater than `epsilon_cutoff` will be sampled. In the paper, suggested values range from 3e-4 to 9e-4, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.\n   * @param {number} [kwargs.eta_cutoff=0.0] Eta sampling is a hybrid of locally typical sampling and epsilon sampling. If set to float strictly between 0 and 1, a token is only considered if it is greater than either `eta_cutoff` or `sqrt(eta_cutoff) * exp(-entropy(softmax(next_token_logits)))`. The latter term is intuitively the expected next token probability, scaled by `sqrt(eta_cutoff)`. In the paper, suggested values range from 3e-4 to 2e-3, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.\n   * @param {number} [kwargs.diversity_penalty=0.0] This value is subtracted from a beam's score if it generates a token same as any beam from other group at a particular time. Note that `diversity_penalty` is only effective if `group beam search` is enabled.\n   * @param {number} [kwargs.repetition_penalty=1.0] The parameter for repetition penalty. 1.0 means no penalty. See [this paper](https://arxiv.org/pdf/1909.05858.pdf) for more details.\n   * @param {number} [kwargs.encoder_repetition_penalty=1.0] The paramater for encoder_repetition_penalty. An exponential penalty on sequences that are not in the original input. 1.0 means no penalty.\n   * @param {number} [kwargs.length_penalty=1.0] Exponential penalty to the length that is used with beam-based generation. It is applied as an exponent to the sequence length, which in turn is used to divide the score of the sequence. Since the score is the log likelihood of the sequence (i.e. negative), `length_penalty` > 0.0 promotes longer sequences, while `length_penalty` < 0.0 encourages shorter sequences.\n   * @param {number} [kwargs.no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size can only occur once.\n   * @param {number[][]} [kwargs.bad_words_ids=null] List of token ids that are not allowed to be generated. In order to get the token ids of the words that should not appear in the generated text, use `(await tokenizer(bad_words, {add_prefix_space: true, add_special_tokens: false})).input_ids`.\n   * @param {number[][]|number[][][]} [kwargs.force_words_ids=null] List of token ids that must be generated. If given a `number[][]`, this is treated as a simple list of words that must be included, the opposite to `bad_words_ids`. If given `number[][][]`, this triggers a [disjunctive constraint](https://github.com/huggingface/transformers/issues/14081), where one can allow different forms of each word.\n   * @param {boolean} [kwargs.renormalize_logits=false] Whether to renormalize the logits after applying all the logits processors or warpers (including the custom ones). It's highly recommended to set this flag to `true` as the search algorithms suppose the score logits are normalized but some logit processors or warpers break the normalization.\n   * @param {Object[]} [kwargs.constraints=null] Custom constraints that can be added to the generation to ensure that the output will contain the use of certain tokens as defined by `Constraint` objects, in the most sensible way possible.\n   * \n   * @param {number} [kwargs.forced_bos_token_id=null] The id of the token to force as the first generated token after the `decoder_start_token_id`. Useful for multilingual models like mBART where the first generated token needs to be the target language token.\n   * @param {number|number[]} [kwargs.forced_eos_token_id=null] The id of the token to force as the last generated token when `max_length` is reached. Optionally, use a list to set multiple *end-of-sequence* tokens.\n   * @param {boolean} [kwargs.remove_invalid_values=false] Whether to remove possible *nan* and *inf* outputs of the model to prevent the generation method to crash. Note that using `remove_invalid_values` can slow down generation.\n   * @param {number[]} [kwargs.exponential_decay_length_penalty=null] This Tuple adds an exponentially increasing length penalty, after a certain amount of tokens have been generated. The tuple shall consist of: `(start_index, decay_factor)` where `start_index` indicates where penalty starts and `decay_factor` represents the factor of exponential decay.\n   * @param {number[]} [kwargs.suppress_tokens=null] A list of tokens that will be suppressed at generation. The `SupressTokens` logit processor will set their log probs to `-inf` so that they are not sampled.\n   * @param {number[]} [kwargs.begin_suppress_tokens=null] A list of tokens that will be suppressed at the beginning of the generation. The `SupressBeginTokens` logit processor will set their log probs to `-inf` so that they are not sampled.\n   * @param {number[][]} [kwargs.forced_decoder_ids=null] A list of pairs of integers which indicates a mapping from generation indices to token indices that will be forced before sampling. For example, `[[1, 123]]` means the second generated token will always be a token of index 123.\n   * \n   * @param {number} [kwargs.num_return_sequences=1] The number of independently computed returned sequences for each element in the batch.\n   * @param {boolean} [kwargs.output_attentions=false] Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned tensors for more details.\n   * @param {boolean} [kwargs.output_hidden_states=false] Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for more details.\n   * @param {boolean} [kwargs.output_scores=false] Whether or not to return the prediction scores. See `scores` under returned tensors for more details.\n   * @param {boolean} [kwargs.return_dict_in_generate=false] Whether or not to return a `ModelOutput` instead of a plain tuple.\n   * \n   * @param {number} [kwargs.pad_token_id=null] The id of the *padding* token.\n   * @param {number} [kwargs.bos_token_id=null] The id of the *beginning-of-sequence* token.\n   * @param {number|number[]} [kwargs.eos_token_id=null] The id of the *end-of-sequence* token. Optionally, use a list to set multiple *end-of-sequence* tokens.\n   * \n   * @param {number} [kwargs.encoder_no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size that occur in the `encoder_input_ids` cannot occur in the `decoder_input_ids`.\n   * @param {number} [kwargs.decoder_start_token_id=null] If an encoder-decoder model starts decoding with a different token than *bos*, the id of that token.\n   * \n   * @param {Object} [kwargs.generation_kwargs={}] Additional generation kwargs will be forwarded to the `generate` function of the model. Kwargs that are not present in `generate`'s signature will be used in the model forward pass.\n   */\n  constructor() {\n    let kwargs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Parameters that control the length of the output\n    this.max_length = kwargs.max_length ?? 20;\n    this.max_new_tokens = kwargs.max_new_tokens ?? null;\n    this.min_length = kwargs.min_length ?? 0;\n    this.min_new_tokens = kwargs.min_new_tokens ?? null;\n    this.early_stopping = kwargs.early_stopping ?? false;\n    this.max_time = kwargs.max_time ?? null;\n\n    // Parameters that control the generation strategy used\n    this.do_sample = kwargs.do_sample ?? false;\n    this.num_beams = kwargs.num_beams ?? 1;\n    this.num_beam_groups = kwargs.num_beam_groups ?? 1;\n    this.penalty_alpha = kwargs.penalty_alpha ?? null;\n    this.use_cache = kwargs.use_cache ?? true;\n\n    // Parameters for manipulation of the model output logits\n    this.temperature = kwargs.temperature ?? 1.0;\n    this.top_k = kwargs.top_k ?? 50;\n    this.top_p = kwargs.top_p ?? 1.0;\n    this.typical_p = kwargs.typical_p ?? 1.0;\n    this.epsilon_cutoff = kwargs.epsilon_cutoff ?? 0.0;\n    this.eta_cutoff = kwargs.eta_cutoff ?? 0.0;\n    this.diversity_penalty = kwargs.diversity_penalty ?? 0.0;\n    this.repetition_penalty = kwargs.repetition_penalty ?? 1.0;\n    this.encoder_repetition_penalty = kwargs.encoder_repetition_penalty ?? 1.0;\n    this.length_penalty = kwargs.length_penalty ?? 1.0;\n    this.no_repeat_ngram_size = kwargs.no_repeat_ngram_size ?? 0;\n    this.bad_words_ids = kwargs.bad_words_ids ?? null;\n    this.force_words_ids = kwargs.force_words_ids ?? null;\n    this.renormalize_logits = kwargs.renormalize_logits ?? false;\n    this.constraints = kwargs.constraints ?? null;\n    this.forced_bos_token_id = kwargs.forced_bos_token_id ?? null;\n    this.forced_eos_token_id = kwargs.forced_eos_token_id ?? null;\n    this.remove_invalid_values = kwargs.remove_invalid_values ?? false;\n    this.exponential_decay_length_penalty = kwargs.exponential_decay_length_penalty ?? null;\n    this.suppress_tokens = kwargs.suppress_tokens ?? null;\n    this.begin_suppress_tokens = kwargs.begin_suppress_tokens ?? null;\n    this.forced_decoder_ids = kwargs.forced_decoder_ids ?? null;\n\n    // Parameters that define the output variables of `generate`\n    this.num_return_sequences = kwargs.num_return_sequences ?? 1;\n    this.output_attentions = kwargs.output_attentions ?? false;\n    this.output_hidden_states = kwargs.output_hidden_states ?? false;\n    this.output_scores = kwargs.output_scores ?? false;\n    this.return_dict_in_generate = kwargs.return_dict_in_generate ?? false;\n\n    // Special tokens that can be used at generation time\n    this.pad_token_id = kwargs.pad_token_id ?? null;\n    this.bos_token_id = kwargs.bos_token_id ?? null;\n    this.eos_token_id = kwargs.eos_token_id ?? null;\n\n    // Generation parameters exclusive to encoder-decoder models\n    this.encoder_no_repeat_ngram_size = kwargs.encoder_no_repeat_ngram_size ?? 0;\n    this.decoder_start_token_id = kwargs.decoder_start_token_id ?? null;\n\n    // Wild card\n    this.generation_kwargs = kwargs.generation_kwargs ?? {};\n  }\n}\n\n/**\n * Sampler is a base class for all sampling methods used for text generation.\n */\nexport class Sampler extends Callable {\n  /**\n   * Creates a new Sampler object with the specified temperature.\n   * @param {number} temperature The temperature to use when sampling. Higher values result in more random samples.\n   */\n  constructor(temperature) {\n    super();\n    this.temperature = temperature;\n  }\n\n  /**\n   * Executes the sampler, using the specified logits.\n   * @param {any} logits\n   * @param {number} index\n   * @returns {void}\n   */\n  _call(logits) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    // Sample from logits, of dims [batch, sequence_length, vocab_size].\n    // If index is specified, sample from [batch, index, vocab_size].\n    return this.sample(logits, index);\n  }\n\n  /**\n   * Abstract method for sampling the logits.\n   * @param {any} logits\n   * @param {number} index\n   * @throws {Error}\n   */\n  sample(logits, index) {\n    throw Error(\"sample should be implemented in subclasses.\");\n  }\n\n  /**\n   * Returns the specified logits as an array, with temperature applied.\n   * @param {any} logits\n   * @param {number} index\n   * @returns {Array}\n   */\n  getLogits(logits, index) {\n    let vocabSize = logits.dims[2];\n    let logs = logits.data;\n    if (index === -1) {\n      logs = logs.slice(-vocabSize);\n    } else {\n      let startIndex = index * vocabSize;\n      logs = logs.slice(startIndex, startIndex + vocabSize);\n    }\n\n    // add temperature\n    if (this.temperature > 0) {\n      logs = logs.map(x => x / this.temperature);\n    }\n    return logs;\n  }\n\n  /**\n   * Selects an item randomly based on the specified probabilities.\n   * @param {Array} probabilities An array of probabilities to use for selection.\n   * @returns {number} The index of the selected item.\n   */\n  randomSelect(probabilities) {\n    // Return index of chosen item\n    let sumProbabilities = probabilities.reduce((acc, curr) => acc + curr, 0);\n    let r = Math.random() * sumProbabilities;\n    for (let i = 0; i < probabilities.length; ++i) {\n      r -= probabilities[i];\n      if (r <= 0) {\n        return i;\n      }\n    }\n    return 0; // return first (most probable) as a fallback\n  }\n\n  /**\n   * Returns a Sampler object based on the specified options.\n   * @param {Object} generation_config An object containing options for the sampler.\n   * @returns {Sampler} A Sampler object.\n   */\n  static getSampler(generation_config) {\n    if (generation_config.num_beams > 1) {\n      return new BeamSearchSampler(generation_config.temperature, generation_config.num_beams, generation_config.do_sample, generation_config.top_k);\n    } else if (generation_config.do_sample) {\n      return new TopKSampler(generation_config.temperature, generation_config.top_k);\n    } else {\n      if (generation_config.num_return_sequences > 1) {\n        throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${generation_config.num_return_sequences}.`);\n      }\n      return new GreedySampler(generation_config.temperature);\n    }\n  }\n}\n\n/**\n * Class representing a Greedy Sampler.\n * @extends Sampler\n */\nclass GreedySampler extends Sampler {\n  /**\n   * Sample the maximum probability of a given logits tensor.\n   * @param {any} logits\n   * @param {number} [index=-1]\n   * @returns {Array} An array with a single tuple, containing the index of the maximum value and a meaningless score (since this is a greedy search).\n   */\n  sample(logits) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    // NOTE: no need to do log_softmax here since we only take the maximum\n    let logs = this.getLogits(logits, index);\n    let argmax = max(logs)[1];\n\n    // Note: score is meaningless in this context, since we are performing\n    // greedy search (p = 1 => log(p) = 0)\n    return [[argmax, 0]];\n  }\n}\n\n/**\n * Class representing a TopKSampler.\n * @extends Sampler\n */\nclass TopKSampler extends Sampler {\n  /**\n   * Create a TopKSampler.\n   * @param {number} temperature\n   * @param {number} k\n   */\n  constructor(temperature, k) {\n    super(temperature);\n    this.k = k;\n  }\n\n  /**\n   * Sample from the logits using the top-k sampling strategy.\n   * @param {any} logits\n   * @param {number} index\n   * @returns {Array}\n   */\n  sample(logits) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let [batchSize, seqLength, vocabSize] = logits.dims;\n    let k = vocabSize;\n    if (this.k > 0) {\n      k = Math.min(this.k, k);\n    }\n    let logs = this.getLogits(logits, index);\n\n    // Get top k tokens\n    let topLogits = getTopItems(logs, k);\n\n    // Compute softmax over logits\n    let probabilities = softmax(topLogits.map(x => x[1]));\n    let sampledIndex = this.randomSelect(probabilities);\n    let tokenId = topLogits[sampledIndex][0];\n    let score = Math.log(probabilities[sampledIndex]);\n    return [[tokenId, score]];\n  }\n}\n\n/**\n * Class representing a beam search sampler for generating sequences.\n * @extends Sampler\n */\nclass BeamSearchSampler extends Sampler {\n  /**\n  * Create a BeamSearchSampler.\n  * @param {number} temperature\n  * @param {number} num_beams\n  * @param {boolean} do_sample\n  * @param {number} top_k\n  */\n  constructor(temperature, num_beams, do_sample, top_k) {\n    super(temperature);\n    this.num_beams = num_beams; // maximum number of beams\n    this.do_sample = do_sample; // if true, perform multinomial sampling\n\n    this.top_k = top_k; // if do_sample, sample from top k items\n  }\n\n  /**\n  * Samples from the logits to generate a sequence using beam search.\n  * @param {any} logits The logits to sample from.\n  * @param {number} [index=-1] The index to sample from, if applicable.\n  * @returns {Array} An array of arrays containing tokens and scores.\n  */\n  sample(logits) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let logs = this.getLogits(logits, index);\n    if (this.do_sample || this.top_k > 0) {\n      const [batchSize, seqLength, vocabSize] = logits.dims;\n      let k = vocabSize;\n      if (this.top_k > 0) {\n        k = Math.min(this.top_k, k);\n      }\n      const topLogits = getTopItems(logs, k);\n\n      // Compute softmax over top k logits\n      const probabilities = softmax(topLogits.map(x => x[1]));\n      return Array.from({\n        length: this.num_beams\n      }, () => {\n        const sampledIndex = this.randomSelect(probabilities);\n        const tokenId = topLogits[sampledIndex][0];\n        return [tokenId, Math.log(probabilities[sampledIndex])];\n      });\n    } else {\n      // first perform log softmax to get scores over whole distribution\n      const logProbabilities = log_softmax(logs);\n      const topLogits = getTopItems(logProbabilities, this.num_beams);\n      return topLogits;\n    }\n  }\n}","map":{"version":3,"names":["Tensor","Callable","exists","max","softmax","log_softmax","getTopItems","LogitsProcessorList","constructor","processors","push","item","extend","items","_call","input_ids","batchedLogits","logits","forEach","func","Symbol","iterator","values","LogitsProcessor","Error","ForceTokensLogitsProcessor","forced_decoder_ids","force_token_map","Object","fromEntries","map","length","data","fill","Infinity","ForcedBOSTokenLogitsProcessor","bos_token_id","ForcedEOSTokenLogitsProcessor","max_length","forced_eos_token_id","SuppressTokensAtBeginLogitsProcessor","begin_suppress_tokens","begin_index","token_id","WhisperTimeStampLogitsProcessor","generate_config","eos_token_id","no_timestamps_token_id","timestamp_begin","slice","max_initial_timestamp_index","seq","last_was_timestamp","penultimate_was_timestamp","subarray","last_allowed","logprobs","timestamp_logprob","Math","log","exp","reduce","a","b","max_text_token_logprob","NoRepeatNGramLogitsProcessor","no_repeat_ngram_size","getNgrams","prevInputIds","curLen","ngrams","j","ngram","k","generatedNgram","Map","prevNgram","prevNgramKey","JSON","stringify","prevNgramValue","get","set","getGeneratedNgrams","bannedNgrams","ngramIdx","banned","calcBannedNgramTokens","bannedTokens","generatedNgrams","token","RepetitionPenaltyLogitsProcessor","penalty","input_id","GenerationConfig","kwargs","arguments","undefined","max_new_tokens","min_length","min_new_tokens","early_stopping","max_time","do_sample","num_beams","num_beam_groups","penalty_alpha","use_cache","temperature","top_k","top_p","typical_p","epsilon_cutoff","eta_cutoff","diversity_penalty","repetition_penalty","encoder_repetition_penalty","length_penalty","bad_words_ids","force_words_ids","renormalize_logits","constraints","forced_bos_token_id","remove_invalid_values","exponential_decay_length_penalty","suppress_tokens","num_return_sequences","output_attentions","output_hidden_states","output_scores","return_dict_in_generate","pad_token_id","encoder_no_repeat_ngram_size","decoder_start_token_id","generation_kwargs","Sampler","index","sample","getLogits","vocabSize","dims","logs","startIndex","x","randomSelect","probabilities","sumProbabilities","acc","curr","r","random","i","getSampler","generation_config","BeamSearchSampler","TopKSampler","GreedySampler","argmax","batchSize","seqLength","min","topLogits","sampledIndex","tokenId","score","Array","from","logProbabilities"],"sources":["/Users/phreetech13/Desktop/RealTimeAudioToText/node_modules/@xenova/transformers/src/utils/generation.js"],"sourcesContent":["\n/**\n * @file Classes, functions, and utilities for generation.\n * \n * @todo Describe how to create a custom `GenerationConfig`.\n * \n * @module utils/generation\n */\nimport { Tensor } from './tensor.js';\nimport {\n    Callable,\n    exists,\n} from './core.js';\nimport {\n    max,\n    softmax,\n    log_softmax,\n    getTopItems,\n} from './maths.js';\n\n/**\n * A class representing a list of logits processors. A logits processor is a function that modifies the logits\n * output of a language model. This class provides methods for adding new processors and applying all processors to a\n * batch of logits.\n *\n * @extends Callable\n */\nexport class LogitsProcessorList extends Callable {\n    /**\n     * Constructs a new instance of `LogitsProcessorList`.\n     */\n    constructor() {\n        super();\n        this.processors = [];\n    }\n\n    /**\n     * Adds a new logits processor to the list.\n     *\n     * @param {LogitsProcessor} item The logits processor function to add.\n     */\n    push(item) {\n        this.processors.push(item);\n    }\n\n    /**\n     * Adds multiple logits processors to the list.\n     *\n     * @param {LogitsProcessor[]} items The logits processor functions to add.\n     */\n    extend(items) {\n        this.processors.push(...items);\n    }\n\n    /**\n     * Applies all logits processors in the list to a batch of logits, modifying them in-place.\n     *\n     * @param {number[]} input_ids The input IDs for the language model.\n     * @param {number[][]} batchedLogits A 2D array of logits, where each row corresponds to a single\n     *                                                input sequence in the batch.\n     */\n    _call(input_ids, batchedLogits) {\n        // NOTE: This is different from the Python code, since vanilla JS does not support vectorized operations. \n        // As a result, we apply each processor to each item in the batch.\n        for (let logits of batchedLogits) {\n            // Modifies logits inplace\n            this.processors.forEach(\n                func => func(input_ids, logits)\n            )\n        }\n    }\n\n    [Symbol.iterator]() {\n        return this.processors.values();\n    }\n}\n\n/**\n * Base class for processing logits.\n * @extends Callable\n */\nexport class LogitsProcessor extends Callable {\n    /**\n     * Apply the processor to the input logits.\n     *\n     * @abstract\n     * @param {Array} input_ids The input ids.\n     * @param {Tensor} logits The logits to process.\n     * @throws {Error} Throws an error if `_call` is not implemented in the subclass.\n     */\n    _call(input_ids, logits) {\n        throw Error(\"`_call` should be implemented in a subclass\")\n    }\n}\n\n/**\n * A logits processor that forces a specific token to be generated by the decoder.\n * \n * @extends LogitsProcessor\n */\nexport class ForceTokensLogitsProcessor extends LogitsProcessor {\n    /**\n     * Constructs a new instance of `ForceTokensLogitsProcessor`.\n     * \n     * @param {Array} forced_decoder_ids The ids of tokens that should be forced.\n     */\n    constructor(forced_decoder_ids) {\n        super();\n        this.force_token_map = Object.fromEntries(forced_decoder_ids ?? []);\n    }\n\n    /**\n     * Apply the processor to the input logits.\n     *\n     * @param {Array} input_ids The input ids.\n     * @param {any} logits The logits to process.\n     * @returns {Array} The processed logits.\n     */\n    _call(input_ids, logits) {\n        let map = this.force_token_map[input_ids.length];\n        if (exists(map)) { // There exists a mapping\n            logits.data.fill(-Infinity)\n            logits.data[map] = 0;\n        }\n        return logits;\n    }\n}\n\n/**\n * A LogitsProcessor that forces a BOS token at the beginning of the generated sequence.\n * @extends LogitsProcessor\n */\nexport class ForcedBOSTokenLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a ForcedBOSTokenLogitsProcessor.\n     * @param {number} bos_token_id The ID of the beginning-of-sequence token to be forced.\n     */\n    constructor(bos_token_id) {\n        super();\n        this.bos_token_id = bos_token_id;\n    }\n\n    /**\n     * Apply the BOS token forcing to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with BOS token forcing.\n     */\n    _call(input_ids, logits) {\n        if (input_ids.length === 1) {\n            logits.data.fill(-Infinity)\n            logits.data[this.bos_token_id] = 0;\n        }\n        return logits;\n    }\n}\n\n/**\n * A logits processor that forces end-of-sequence token probability to 1.\n * \n * @extends LogitsProcessor\n */\nexport class ForcedEOSTokenLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a ForcedEOSTokenLogitsProcessor.\n     * @param {number} max_length Max length of the sequence.\n     * @param {number|number[]} forced_eos_token_id The ID of the end-of-sequence token to be forced.\n     */\n    constructor(max_length, forced_eos_token_id) {\n        super();\n        this.max_length = max_length;\n        this.forced_eos_token_id = forced_eos_token_id;\n    }\n\n    /**\n     * Apply the processor to input_ids and logits.\n     * \n     * @param {number[]} input_ids The input ids.\n     * @param {any} logits The logits tensor.\n     */\n    _call(input_ids, logits) {\n        // console.log('call ForcedEOSTokenLogitsProcessor')\n        // TODO\n    }\n}\n\n/**\n * A LogitsProcessor that suppresses a list of tokens as soon as the `generate` function starts\n * generating using `begin_index` tokens. This should ensure that the tokens defined by\n * `begin_suppress_tokens` at not sampled at the begining of the generation.\n * @extends LogitsProcessor\n */\nexport class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a SuppressTokensAtBeginLogitsProcessor.\n     * @param {number[]} begin_suppress_tokens The IDs of the tokens to suppress.\n     * @param {number} begin_index The number of tokens to generate before suppressing tokens.\n     */\n    constructor(begin_suppress_tokens, begin_index) {\n        super();\n        this.begin_suppress_tokens = begin_suppress_tokens;\n        this.begin_index = begin_index;\n    }\n\n    /**\n     * Apply the BOS token forcing to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with BOS token forcing.\n     */\n    _call(input_ids, logits) {\n        if (input_ids.length === this.begin_index) {\n            for (let token_id of this.begin_suppress_tokens) {\n                logits.data[token_id] = -Infinity;\n            }\n        }\n        return logits;\n    }\n}\n\n/**\n * A LogitsProcessor that handles adding timestamps to generated text.\n * @extends LogitsProcessor\n */\nexport class WhisperTimeStampLogitsProcessor extends LogitsProcessor {\n    /**\n     * Constructs a new WhisperTimeStampLogitsProcessor.\n     * @param {Object} generate_config The config object passed to the `generate()` method of a transformer model.\n     * @param {number} generate_config.eos_token_id The ID of the end-of-sequence token.\n     * @param {number} generate_config.no_timestamps_token_id The ID of the token used to indicate that a token should not have a timestamp.\n     * @param {number[][]} [generate_config.forced_decoder_ids] An array of two-element arrays representing decoder IDs that are forced to appear in the output. The second element of each array indicates whether the token is a timestamp.\n     * @param {number} [generate_config.max_initial_timestamp_index] The maximum index at which an initial timestamp can appear.\n     */\n    constructor(generate_config) {\n        super();\n        this.eos_token_id = generate_config.eos_token_id;\n        this.no_timestamps_token_id = generate_config.no_timestamps_token_id;\n        this.timestamp_begin = this.no_timestamps_token_id + 1;\n\n        this.begin_index = (generate_config.forced_decoder_ids || []).length + 2;\n        if (generate_config.forced_decoder_ids.slice(-1)[0][1] === this.no_timestamps_token_id) {\n            this.begin_index -= 1;\n        }\n        this.max_initial_timestamp_index = generate_config.max_initial_timestamp_index;\n\n    }\n\n    /**\n     * Modify the logits to handle timestamp tokens.\n     * @param {Array} input_ids The input sequence of tokens.\n     * @param {Tensor} logits The logits output by the model.\n     * @returns {Tensor} The modified logits.\n     */\n    _call(input_ids, logits) {\n        // suppress <|notimestamps|> which is handled by without_timestamps\n        logits.data[this.no_timestamps_token_id] = -Infinity;\n\n        if (input_ids.length === this.begin_index - 1) {\n            logits.data.fill(-Infinity);\n            logits.data[this.timestamp_begin] = 0;\n            return logits;\n        }\n\n        // timestamps have to appear in pairs, except directly before eos_token; mask logits accordingly\n        const seq = input_ids.slice(this.begin_index);\n        const last_was_timestamp = seq.length >= 1 && seq[seq.length - 1] >= this.timestamp_begin;\n        const penultimate_was_timestamp = seq.length < 2 || seq[seq.length - 2] >= this.timestamp_begin;\n\n        if (last_was_timestamp) {\n            if (penultimate_was_timestamp) { // has to be non-timestamp\n                logits.data.subarray(this.timestamp_begin).fill(-Infinity);\n            } else { // cannot be normal text tokens\n                logits.data.subarray(0, this.eos_token_id).fill(-Infinity);\n            }\n        }\n\n        // apply the `max_initial_timestamp` option\n        if (input_ids.length === this.begin_index && this.max_initial_timestamp_index !== null) {\n            const last_allowed = this.timestamp_begin + this.max_initial_timestamp_index;\n            logits.data.subarray(last_allowed + 1).fill(-Infinity);\n        }\n\n        // if sum of probability over timestamps is above any other token, sample timestamp\n        const logprobs = log_softmax(logits.data);\n        const timestamp_logprob = Math.log(logprobs.subarray(this.timestamp_begin).map(Math.exp).reduce((a, b) => a + b));\n        const max_text_token_logprob = max(logprobs.subarray(0, this.timestamp_begin))[0];\n\n        if (timestamp_logprob > max_text_token_logprob) {\n            logits.data.subarray(0, this.timestamp_begin).fill(-Infinity);\n        }\n\n        return logits;\n    }\n}\n\n/**\n * A logits processor that disallows ngrams of a certain size to be repeated.\n * \n * @extends LogitsProcessor\n */\nexport class NoRepeatNGramLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a NoRepeatNGramLogitsProcessor.\n     * @param {number} no_repeat_ngram_size The no-repeat-ngram size. All ngrams of this size can only occur once.\n     */\n    constructor(no_repeat_ngram_size) {\n        super();\n        this.no_repeat_ngram_size = no_repeat_ngram_size;\n    }\n\n    /**\n     * Generate n-grams from a sequence of token ids.\n     * @param {number[]} prevInputIds List of previous input ids\n     * @returns {Map<string, number[]>} Map of generated n-grams\n     */\n    getNgrams(prevInputIds) {\n        const curLen = prevInputIds.length;\n\n        /**@type {number[][]} */\n        const ngrams = [];\n        for (let j = 0; j < curLen + 1 - this.no_repeat_ngram_size; ++j) {\n            const ngram = [];\n            for (let k = 0; k < this.no_repeat_ngram_size; ++k) {\n                ngram.push(prevInputIds[j + k]);\n            }\n            ngrams.push(ngram);\n        }\n\n        /** @type {Map<string, number[]>} */\n        const generatedNgram = new Map();\n        for (const ngram of ngrams) {\n            const prevNgram = ngram.slice(0, ngram.length - 1);\n            const prevNgramKey = JSON.stringify(prevNgram);\n            const prevNgramValue = generatedNgram.get(prevNgramKey) ?? [];\n            prevNgramValue.push(ngram[ngram.length - 1]);\n            generatedNgram.set(prevNgramKey, prevNgramValue);\n        }\n        return generatedNgram;\n    }\n\n    /**\n     * Generate n-grams from a sequence of token ids.\n     * @param {Map<string, number[]>} bannedNgrams Map of banned n-grams\n     * @param {number[]} prevInputIds List of previous input ids\n     * @returns {number[]} Map of generated n-grams\n     */\n    getGeneratedNgrams(bannedNgrams, prevInputIds) {\n        const ngramIdx = prevInputIds.slice(prevInputIds.length + 1 - this.no_repeat_ngram_size, prevInputIds.length);\n        const banned = bannedNgrams.get(JSON.stringify(ngramIdx)) ?? [];\n        return banned;\n    }\n\n    /**\n     * Calculate banned n-gram tokens\n     * @param {number[]} prevInputIds List of previous input ids\n     * @returns {number[]} Map of generated n-grams\n     */\n    calcBannedNgramTokens(prevInputIds) {\n        const bannedTokens = [];\n        if (prevInputIds.length + 1 < this.no_repeat_ngram_size) {\n            // return no banned tokens if we haven't generated no_repeat_ngram_size tokens yet\n            return bannedTokens;\n\n        } else {\n            const generatedNgrams = this.getNgrams(prevInputIds);\n            const bannedTokens = this.getGeneratedNgrams(generatedNgrams, prevInputIds);\n            return bannedTokens;\n        }\n    }\n\n    /**\n     * Apply the no-repeat-ngram processor to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with no-repeat-ngram processing.\n     */\n    _call(input_ids, logits) {\n        const bannedTokens = this.calcBannedNgramTokens(input_ids);\n\n        for (const token of bannedTokens) {\n            logits.data[token] = -Infinity;\n        }\n        return logits;\n    }\n}\n\n/**\n * A logits processor that penalises repeated output tokens.\n * \n * @extends LogitsProcessor\n */\nexport class RepetitionPenaltyLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a RepetitionPenaltyLogitsProcessor.\n     * @param {number} penalty The penalty to apply for repeated tokens.\n     */\n    constructor(penalty) {\n        super();\n        this.penalty = penalty;\n    }\n\n    /**\n     * Apply the repetition penalty to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with repetition penalty processing.\n     */\n    _call(input_ids, logits) {\n        // Modify the logits corresponding to each element in `input_ids`.\n        // As a consequence, the logits corresponding to tokens that appear\n        // many times in the output will be penalised more.\n        for (const input_id of input_ids) {\n            if (logits.data[input_id] < 0) {\n                logits.data[input_id] *= this.penalty;\n            } else {\n                logits.data[input_id] /= this.penalty;\n            }\n        }\n        return logits\n    }\n}\n\n/**\n * Class that holds a configuration for a generation task.\n */\nexport class GenerationConfig {\n    /**\n     * Create a GenerationConfig object\n     * @param {Object} [kwargs={}] The configuration parameters. If not set, the default values are used.\n     * @param {number} [kwargs.max_length=20] The maximum length the generated tokens can have. Corresponds to the length of the input prompt + `max_new_tokens`. Its effect is overridden by `max_new_tokens`, if also set.\n     * @param {number} [kwargs.max_new_tokens=null] The maximum numbers of tokens to generate, ignoring the number of tokens in the prompt.\n     * @param {number} [kwargs.min_length=0] The minimum length of the sequence to be generated. Corresponds to the length of the input prompt + `min_new_tokens`. Its effect is overridden by `min_new_tokens`, if also set.\n     * @param {number} [kwargs.min_new_tokens=null] The minimum numbers of tokens to generate, ignoring the number of tokens in the prompt.\n     * @param {boolean|\"never\"} [kwargs.early_stopping=false] Controls the stopping condition for beam-based methods, like beam-search. It accepts the following values:\n     * - `true`, where the generation stops as soon as there are `num_beams` complete candidates;\n     * - `false`, where an heuristic is applied and the generation stops when is it very unlikely to find better candidates;\n     * - `\"never\"`, where the beam search procedure only stops when there cannot be better candidates (canonical beam search algorithm).\n     * @param {number} [kwargs.max_time=null] The maximum amount of time you allow the computation to run for in seconds. Generation will still finish the current pass after allocated time has been passed.\n     *\n     * @param {boolean} [kwargs.do_sample=false] Whether or not to use sampling; use greedy decoding otherwise.\n     * @param {number} [kwargs.num_beams=1] Number of beams for beam search. 1 means no beam search.\n     * @param {number} [kwargs.num_beam_groups=1] Number of groups to divide `num_beams` into in order to ensure diversity among different groups of beams. See [this paper](https://arxiv.org/pdf/1610.02424.pdf) for more details.\n     * @param {number} [kwargs.penalty_alpha=null] The values balance the model confidence and the degeneration penalty in contrastive search decoding.\n     * @param {boolean} [kwargs.use_cache=true] Whether or not the model should use the past last key/values attentions (if applicable to the model) to speed up decoding.\n     *\n     * @param {number} [kwargs.temperature=1.0] The value used to modulate the next token probabilities.\n     * @param {number} [kwargs.top_k=50] The number of highest probability vocabulary tokens to keep for top-k-filtering.\n     * @param {number} [kwargs.top_p=1.0] If set to float < 1, only the smallest set of most probable tokens with probabilities that add up to `top_p` or higher are kept for generation.\n     * @param {number} [kwargs.typical_p=1.0] Local typicality measures how similar the conditional probability of predicting a target token next is to the expected conditional probability of predicting a random token next, given the partial text already generated. If set to float < 1, the smallest set of the most locally typical tokens with probabilities that add up to `typical_p` or higher are kept for generation. See [this paper](https://arxiv.org/pdf/2202.00666.pdf) for more details.\n     * @param {number} [kwargs.epsilon_cutoff=0.0] If set to float strictly between 0 and 1, only tokens with a conditional probability greater than `epsilon_cutoff` will be sampled. In the paper, suggested values range from 3e-4 to 9e-4, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.\n     * @param {number} [kwargs.eta_cutoff=0.0] Eta sampling is a hybrid of locally typical sampling and epsilon sampling. If set to float strictly between 0 and 1, a token is only considered if it is greater than either `eta_cutoff` or `sqrt(eta_cutoff) * exp(-entropy(softmax(next_token_logits)))`. The latter term is intuitively the expected next token probability, scaled by `sqrt(eta_cutoff)`. In the paper, suggested values range from 3e-4 to 2e-3, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.\n     * @param {number} [kwargs.diversity_penalty=0.0] This value is subtracted from a beam's score if it generates a token same as any beam from other group at a particular time. Note that `diversity_penalty` is only effective if `group beam search` is enabled.\n     * @param {number} [kwargs.repetition_penalty=1.0] The parameter for repetition penalty. 1.0 means no penalty. See [this paper](https://arxiv.org/pdf/1909.05858.pdf) for more details.\n     * @param {number} [kwargs.encoder_repetition_penalty=1.0] The paramater for encoder_repetition_penalty. An exponential penalty on sequences that are not in the original input. 1.0 means no penalty.\n     * @param {number} [kwargs.length_penalty=1.0] Exponential penalty to the length that is used with beam-based generation. It is applied as an exponent to the sequence length, which in turn is used to divide the score of the sequence. Since the score is the log likelihood of the sequence (i.e. negative), `length_penalty` > 0.0 promotes longer sequences, while `length_penalty` < 0.0 encourages shorter sequences.\n     * @param {number} [kwargs.no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size can only occur once.\n     * @param {number[][]} [kwargs.bad_words_ids=null] List of token ids that are not allowed to be generated. In order to get the token ids of the words that should not appear in the generated text, use `(await tokenizer(bad_words, {add_prefix_space: true, add_special_tokens: false})).input_ids`.\n     * @param {number[][]|number[][][]} [kwargs.force_words_ids=null] List of token ids that must be generated. If given a `number[][]`, this is treated as a simple list of words that must be included, the opposite to `bad_words_ids`. If given `number[][][]`, this triggers a [disjunctive constraint](https://github.com/huggingface/transformers/issues/14081), where one can allow different forms of each word.\n     * @param {boolean} [kwargs.renormalize_logits=false] Whether to renormalize the logits after applying all the logits processors or warpers (including the custom ones). It's highly recommended to set this flag to `true` as the search algorithms suppose the score logits are normalized but some logit processors or warpers break the normalization.\n     * @param {Object[]} [kwargs.constraints=null] Custom constraints that can be added to the generation to ensure that the output will contain the use of certain tokens as defined by `Constraint` objects, in the most sensible way possible.\n     * \n     * @param {number} [kwargs.forced_bos_token_id=null] The id of the token to force as the first generated token after the `decoder_start_token_id`. Useful for multilingual models like mBART where the first generated token needs to be the target language token.\n     * @param {number|number[]} [kwargs.forced_eos_token_id=null] The id of the token to force as the last generated token when `max_length` is reached. Optionally, use a list to set multiple *end-of-sequence* tokens.\n     * @param {boolean} [kwargs.remove_invalid_values=false] Whether to remove possible *nan* and *inf* outputs of the model to prevent the generation method to crash. Note that using `remove_invalid_values` can slow down generation.\n     * @param {number[]} [kwargs.exponential_decay_length_penalty=null] This Tuple adds an exponentially increasing length penalty, after a certain amount of tokens have been generated. The tuple shall consist of: `(start_index, decay_factor)` where `start_index` indicates where penalty starts and `decay_factor` represents the factor of exponential decay.\n     * @param {number[]} [kwargs.suppress_tokens=null] A list of tokens that will be suppressed at generation. The `SupressTokens` logit processor will set their log probs to `-inf` so that they are not sampled.\n     * @param {number[]} [kwargs.begin_suppress_tokens=null] A list of tokens that will be suppressed at the beginning of the generation. The `SupressBeginTokens` logit processor will set their log probs to `-inf` so that they are not sampled.\n     * @param {number[][]} [kwargs.forced_decoder_ids=null] A list of pairs of integers which indicates a mapping from generation indices to token indices that will be forced before sampling. For example, `[[1, 123]]` means the second generated token will always be a token of index 123.\n     * \n     * @param {number} [kwargs.num_return_sequences=1] The number of independently computed returned sequences for each element in the batch.\n     * @param {boolean} [kwargs.output_attentions=false] Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned tensors for more details.\n     * @param {boolean} [kwargs.output_hidden_states=false] Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for more details.\n     * @param {boolean} [kwargs.output_scores=false] Whether or not to return the prediction scores. See `scores` under returned tensors for more details.\n     * @param {boolean} [kwargs.return_dict_in_generate=false] Whether or not to return a `ModelOutput` instead of a plain tuple.\n     * \n     * @param {number} [kwargs.pad_token_id=null] The id of the *padding* token.\n     * @param {number} [kwargs.bos_token_id=null] The id of the *beginning-of-sequence* token.\n     * @param {number|number[]} [kwargs.eos_token_id=null] The id of the *end-of-sequence* token. Optionally, use a list to set multiple *end-of-sequence* tokens.\n     * \n     * @param {number} [kwargs.encoder_no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size that occur in the `encoder_input_ids` cannot occur in the `decoder_input_ids`.\n     * @param {number} [kwargs.decoder_start_token_id=null] If an encoder-decoder model starts decoding with a different token than *bos*, the id of that token.\n     * \n     * @param {Object} [kwargs.generation_kwargs={}] Additional generation kwargs will be forwarded to the `generate` function of the model. Kwargs that are not present in `generate`'s signature will be used in the model forward pass.\n     */\n    constructor(kwargs = {}) {\n        // Parameters that control the length of the output\n        this.max_length = kwargs.max_length ?? 20;\n        this.max_new_tokens = kwargs.max_new_tokens ?? null;\n        this.min_length = kwargs.min_length ?? 0;\n        this.min_new_tokens = kwargs.min_new_tokens ?? null;\n        this.early_stopping = kwargs.early_stopping ?? false;\n        this.max_time = kwargs.max_time ?? null;\n\n        // Parameters that control the generation strategy used\n        this.do_sample = kwargs.do_sample ?? false;\n        this.num_beams = kwargs.num_beams ?? 1;\n        this.num_beam_groups = kwargs.num_beam_groups ?? 1;\n        this.penalty_alpha = kwargs.penalty_alpha ?? null;\n        this.use_cache = kwargs.use_cache ?? true;\n\n        // Parameters for manipulation of the model output logits\n        this.temperature = kwargs.temperature ?? 1.0;\n        this.top_k = kwargs.top_k ?? 50;\n        this.top_p = kwargs.top_p ?? 1.0;\n        this.typical_p = kwargs.typical_p ?? 1.0;\n        this.epsilon_cutoff = kwargs.epsilon_cutoff ?? 0.0;\n        this.eta_cutoff = kwargs.eta_cutoff ?? 0.0;\n        this.diversity_penalty = kwargs.diversity_penalty ?? 0.0;\n        this.repetition_penalty = kwargs.repetition_penalty ?? 1.0;\n        this.encoder_repetition_penalty = kwargs.encoder_repetition_penalty ?? 1.0;\n        this.length_penalty = kwargs.length_penalty ?? 1.0;\n        this.no_repeat_ngram_size = kwargs.no_repeat_ngram_size ?? 0;\n        this.bad_words_ids = kwargs.bad_words_ids ?? null;\n        this.force_words_ids = kwargs.force_words_ids ?? null;\n        this.renormalize_logits = kwargs.renormalize_logits ?? false;\n        this.constraints = kwargs.constraints ?? null;\n        this.forced_bos_token_id = kwargs.forced_bos_token_id ?? null;\n        this.forced_eos_token_id = kwargs.forced_eos_token_id ?? null;\n        this.remove_invalid_values = kwargs.remove_invalid_values ?? false;\n        this.exponential_decay_length_penalty = kwargs.exponential_decay_length_penalty ?? null;\n        this.suppress_tokens = kwargs.suppress_tokens ?? null;\n        this.begin_suppress_tokens = kwargs.begin_suppress_tokens ?? null;\n        this.forced_decoder_ids = kwargs.forced_decoder_ids ?? null;\n\n        // Parameters that define the output variables of `generate`\n        this.num_return_sequences = kwargs.num_return_sequences ?? 1;\n        this.output_attentions = kwargs.output_attentions ?? false;\n        this.output_hidden_states = kwargs.output_hidden_states ?? false;\n        this.output_scores = kwargs.output_scores ?? false;\n        this.return_dict_in_generate = kwargs.return_dict_in_generate ?? false;\n\n        // Special tokens that can be used at generation time\n        this.pad_token_id = kwargs.pad_token_id ?? null;\n        this.bos_token_id = kwargs.bos_token_id ?? null;\n        this.eos_token_id = kwargs.eos_token_id ?? null;\n\n        // Generation parameters exclusive to encoder-decoder models\n        this.encoder_no_repeat_ngram_size = kwargs.encoder_no_repeat_ngram_size ?? 0;\n        this.decoder_start_token_id = kwargs.decoder_start_token_id ?? null;\n\n        // Wild card\n        this.generation_kwargs = kwargs.generation_kwargs ?? {};\n    }\n}\n\n\n/**\n * Sampler is a base class for all sampling methods used for text generation.\n */\nexport class Sampler extends Callable {\n    /**\n     * Creates a new Sampler object with the specified temperature.\n     * @param {number} temperature The temperature to use when sampling. Higher values result in more random samples.\n     */\n    constructor(temperature) {\n        super();\n        this.temperature = temperature;\n    }\n\n    /**\n     * Executes the sampler, using the specified logits.\n     * @param {any} logits\n     * @param {number} index\n     * @returns {void}\n     */\n    _call(logits, index = -1) {\n        // Sample from logits, of dims [batch, sequence_length, vocab_size].\n        // If index is specified, sample from [batch, index, vocab_size].\n        return this.sample(logits, index);\n    }\n\n    /**\n     * Abstract method for sampling the logits.\n     * @param {any} logits\n     * @param {number} index\n     * @throws {Error}\n     */\n    sample(logits, index) {\n        throw Error(\"sample should be implemented in subclasses.\")\n    }\n\n    /**\n     * Returns the specified logits as an array, with temperature applied.\n     * @param {any} logits\n     * @param {number} index\n     * @returns {Array}\n     */\n    getLogits(logits, index) {\n        let vocabSize = logits.dims[2];\n\n        let logs = logits.data;\n\n        if (index === -1) {\n            logs = logs.slice(-vocabSize);\n        } else {\n            let startIndex = index * vocabSize;\n            logs = logs.slice(startIndex, startIndex + vocabSize);\n        }\n\n        // add temperature\n        if (this.temperature > 0) {\n            logs = logs.map(x => x / this.temperature)\n        }\n        return logs;\n    }\n\n    /**\n     * Selects an item randomly based on the specified probabilities.\n     * @param {Array} probabilities An array of probabilities to use for selection.\n     * @returns {number} The index of the selected item.\n     */\n    randomSelect(probabilities) {\n        // Return index of chosen item\n        let sumProbabilities = probabilities.reduce((acc, curr) => acc + curr, 0);\n\n        let r = Math.random() * sumProbabilities;\n        for (let i = 0; i < probabilities.length; ++i) {\n            r -= probabilities[i];\n            if (r <= 0) {\n                return i;\n            }\n        }\n        return 0; // return first (most probable) as a fallback\n    }\n\n    /**\n     * Returns a Sampler object based on the specified options.\n     * @param {Object} generation_config An object containing options for the sampler.\n     * @returns {Sampler} A Sampler object.\n     */\n    static getSampler(generation_config) {\n        if (generation_config.num_beams > 1) {\n            return new BeamSearchSampler(\n                generation_config.temperature,\n                generation_config.num_beams,\n                generation_config.do_sample,\n                generation_config.top_k,\n            );\n\n        } else if (generation_config.do_sample) {\n            return new TopKSampler(\n                generation_config.temperature,\n                generation_config.top_k,\n            );\n\n        } else {\n            if (generation_config.num_return_sequences > 1) {\n                throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${generation_config.num_return_sequences}.`)\n            }\n            return new GreedySampler(generation_config.temperature);\n        }\n    }\n}\n\n/**\n * Class representing a Greedy Sampler.\n * @extends Sampler\n */\nclass GreedySampler extends Sampler {\n    /**\n     * Sample the maximum probability of a given logits tensor.\n     * @param {any} logits\n     * @param {number} [index=-1]\n     * @returns {Array} An array with a single tuple, containing the index of the maximum value and a meaningless score (since this is a greedy search).\n     */\n    sample(logits, index = -1) {\n        // NOTE: no need to do log_softmax here since we only take the maximum\n        let logs = this.getLogits(logits, index);\n        let argmax = max(logs)[1];\n\n        // Note: score is meaningless in this context, since we are performing\n        // greedy search (p = 1 => log(p) = 0)\n        return [\n            [argmax, 0]\n        ];\n    }\n}\n\n/**\n * Class representing a TopKSampler.\n * @extends Sampler\n */\nclass TopKSampler extends Sampler {\n    /**\n     * Create a TopKSampler.\n     * @param {number} temperature\n     * @param {number} k\n     */\n    constructor(temperature, k) {\n        super(temperature);\n        this.k = k;\n    }\n\n    /**\n     * Sample from the logits using the top-k sampling strategy.\n     * @param {any} logits\n     * @param {number} index\n     * @returns {Array}\n     */\n    sample(logits, index = -1) {\n        let [batchSize, seqLength, vocabSize] = logits.dims;\n        let k = vocabSize;\n        if (this.k > 0) {\n            k = Math.min(this.k, k);\n        }\n\n        let logs = this.getLogits(logits, index);\n\n        // Get top k tokens\n        let topLogits = getTopItems(logs, k);\n\n        // Compute softmax over logits\n        let probabilities = softmax(topLogits.map(x => x[1]));\n\n        let sampledIndex = this.randomSelect(probabilities);\n\n        let tokenId = topLogits[sampledIndex][0];\n        let score = Math.log(probabilities[sampledIndex]);\n        return [\n            [tokenId, score]\n        ];\n    }\n}\n\n/**\n * Class representing a beam search sampler for generating sequences.\n * @extends Sampler\n */\nclass BeamSearchSampler extends Sampler {\n    /**\n   * Create a BeamSearchSampler.\n   * @param {number} temperature\n   * @param {number} num_beams\n   * @param {boolean} do_sample\n   * @param {number} top_k\n   */\n    constructor(temperature, num_beams, do_sample, top_k) {\n        super(temperature);\n        this.num_beams = num_beams; // maximum number of beams\n        this.do_sample = do_sample; // if true, perform multinomial sampling\n\n        this.top_k = top_k; // if do_sample, sample from top k items\n    }\n\n    /**\n   * Samples from the logits to generate a sequence using beam search.\n   * @param {any} logits The logits to sample from.\n   * @param {number} [index=-1] The index to sample from, if applicable.\n   * @returns {Array} An array of arrays containing tokens and scores.\n   */\n    sample(logits, index = -1) {\n\n        let logs = this.getLogits(logits, index);\n\n        if (this.do_sample || this.top_k > 0) {\n            const [batchSize, seqLength, vocabSize] = logits.dims;\n\n            let k = vocabSize;\n            if (this.top_k > 0) {\n                k = Math.min(this.top_k, k);\n            }\n            const topLogits = getTopItems(logs, k);\n\n            // Compute softmax over top k logits\n            const probabilities = softmax(topLogits.map(x => x[1]));\n\n            return Array.from({ length: this.num_beams }, () => {\n                const sampledIndex = this.randomSelect(probabilities);\n                const tokenId = topLogits[sampledIndex][0];\n                return [tokenId, Math.log(probabilities[sampledIndex])];\n            });\n\n        } else {\n            // first perform log softmax to get scores over whole distribution\n            const logProbabilities = log_softmax(logs);\n            const topLogits = getTopItems(logProbabilities, this.num_beams);\n            return topLogits;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}