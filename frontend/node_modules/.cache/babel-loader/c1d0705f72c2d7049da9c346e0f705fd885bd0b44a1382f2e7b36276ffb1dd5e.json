{"ast":null,"code":"/**\n * @file Utility functions to interact with the Hugging Face Hub (https://huggingface.co/models)\n * \n * @module utils/hub\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport stream from 'stream/web';\nimport { env } from '../env.js';\nimport { dispatchCallback } from './core.js';\nif (!globalThis.ReadableStream) {\n  // @ts-ignore\n  globalThis.ReadableStream = stream.ReadableStream; // ReadableStream is not a global with Node 16\n}\n\n/**\n * @typedef {Object} PretrainedOptions Options for loading a pretrained model.     \n * @property {boolean?} [options.quantized=true] Whether to load the 8-bit quantized version of the model (only applicable when loading model files).\n * @property {function} [options.progress_callback=null] If specified, this function will be called during model construction, to provide the user with progress updates.\n * @property {Object} [options.config=null] Configuration for the model to use instead of an automatically loaded configuration. Configuration can be automatically loaded when:\n * - The model is a model provided by the library (loaded with the *model id* string of a pretrained model).\n * - The model is loaded by supplying a local directory as `pretrained_model_name_or_path` and a configuration JSON file named *config.json* is found in the directory.\n * @property {string} [options.cache_dir=null] Path to a directory in which a downloaded pretrained model configuration should be cached if the standard cache should not be used.\n * @property {boolean} [options.local_files_only=false] Whether or not to only look at local files (e.g., not try downloading the model).\n * @property {string} [options.revision='main'] The specific model version to use. It can be a branch name, a tag name, or a commit id,\n * since we use a git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any identifier allowed by git.\n * NOTE: This setting is ignored for local requests.\n */\n\nclass Headers extends Object {\n  constructor() {\n    super();\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    Object.assign(this, args);\n  }\n  get(key) {\n    return this[key];\n  }\n  clone() {\n    return new Headers(this);\n  }\n}\nclass FileResponse {\n  /**\n   * Mapping from file extensions to MIME types.\n   */\n  _CONTENT_TYPE_MAP = {\n    'txt': 'text/plain',\n    'html': 'text/html',\n    'css': 'text/css',\n    'js': 'text/javascript',\n    'json': 'application/json',\n    'png': 'image/png',\n    'jpg': 'image/jpeg',\n    'jpeg': 'image/jpeg',\n    'gif': 'image/gif'\n  };\n  /**\n   * Creates a new `FileResponse` object.\n   * @param {string|URL} filePath\n   */\n  constructor(filePath) {\n    this.filePath = filePath;\n    this.headers = new Headers();\n    this.exists = fs.existsSync(filePath);\n    if (this.exists) {\n      this.status = 200;\n      this.statusText = 'OK';\n      let stats = fs.statSync(filePath);\n      this.headers['content-length'] = stats.size;\n      this.updateContentType();\n      let self = this;\n      this.body = new ReadableStream({\n        start(controller) {\n          self.arrayBuffer().then(buffer => {\n            controller.enqueue(new Uint8Array(buffer));\n            controller.close();\n          });\n        }\n      });\n    } else {\n      this.status = 404;\n      this.statusText = 'Not Found';\n      this.body = null;\n    }\n  }\n\n  /**\n   * Updates the 'content-type' header property of the response based on the extension of\n   * the file specified by the filePath property of the current object.\n   * @returns {void}\n   */\n  updateContentType() {\n    // Set content-type header based on file extension\n    const extension = this.filePath.toString().split('.').pop().toLowerCase();\n    this.headers['content-type'] = this._CONTENT_TYPE_MAP[extension] ?? 'application/octet-stream';\n  }\n\n  /**\n   * Clone the current FileResponse object.\n   * @returns {FileResponse} A new FileResponse object with the same properties as the current object.\n   */\n  clone() {\n    let response = new FileResponse(this.filePath);\n    response.exists = this.exists;\n    response.status = this.status;\n    response.statusText = this.statusText;\n    response.headers = this.headers.clone();\n    return response;\n  }\n\n  /**\n   * Reads the contents of the file specified by the filePath property and returns a Promise that\n   * resolves with an ArrayBuffer containing the file's contents.\n   * @returns {Promise<ArrayBuffer>} A Promise that resolves with an ArrayBuffer containing the file's contents.\n   * @throws {Error} If the file cannot be read.\n   */\n  async arrayBuffer() {\n    const data = await fs.promises.readFile(this.filePath);\n    return data.buffer;\n  }\n\n  /**\n   * Reads the contents of the file specified by the filePath property and returns a Promise that\n   * resolves with a Blob containing the file's contents.\n   * @returns {Promise<Blob>} A Promise that resolves with a Blob containing the file's contents.\n   * @throws {Error} If the file cannot be read.\n   */\n  async blob() {\n    const data = await fs.promises.readFile(this.filePath);\n    return new Blob([data], {\n      type: this.headers['content-type']\n    });\n  }\n\n  /**\n   * Reads the contents of the file specified by the filePath property and returns a Promise that\n   * resolves with a string containing the file's contents.\n   * @returns {Promise<string>} A Promise that resolves with a string containing the file's contents.\n   * @throws {Error} If the file cannot be read.\n   */\n  async text() {\n    const data = await fs.promises.readFile(this.filePath, 'utf8');\n    return data;\n  }\n\n  /**\n   * Reads the contents of the file specified by the filePath property and returns a Promise that\n   * resolves with a parsed JavaScript object containing the file's contents.\n   * \n   * @returns {Promise<Object>} A Promise that resolves with a parsed JavaScript object containing the file's contents.\n   * @throws {Error} If the file cannot be read.\n   */\n  async json() {\n    return JSON.parse(await this.text());\n  }\n}\n\n/**\n * Determines whether the given string is a valid HTTP or HTTPS URL.\n * @param {string|URL} string The string to test for validity as an HTTP or HTTPS URL.\n * @returns {boolean} True if the string is a valid HTTP or HTTPS URL, false otherwise.\n */\nfunction isValidHttpUrl(string) {\n  // https://stackoverflow.com/a/43467144\n  let url;\n  try {\n    url = new URL(string);\n  } catch (_) {\n    return false;\n  }\n  return url.protocol === \"http:\" || url.protocol === \"https:\";\n}\n\n/**\n * Helper function to get a file, using either the Fetch API or FileSystem API.\n *\n * @param {URL|string} urlOrPath The URL/path of the file to get.\n * @returns {Promise<FileResponse|Response>} A promise that resolves to a FileResponse object (if the file is retrieved using the FileSystem API), or a Response object (if the file is retrieved using the Fetch API).\n */\nexport async function getFile(urlOrPath) {\n  if (env.useFS && !isValidHttpUrl(urlOrPath)) {\n    return new FileResponse(urlOrPath);\n  } else if (typeof process !== 'undefined' && process?.release?.name === 'node') {\n    const IS_CI = !!process.env?.TESTING_REMOTELY;\n    const version = env.version;\n    return fetch(urlOrPath, {\n      headers: {\n        'User-Agent': `transformers.js/${version}; is_ci/${IS_CI};`\n      }\n    });\n  } else {\n    // Running in a browser-environment, so we use default headers\n    return fetch(urlOrPath);\n  }\n}\nconst ERROR_MAPPING = {\n  // 4xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)\n  400: 'Bad request error occurred while trying to load file',\n  401: 'Unauthorized access to file',\n  403: 'Forbidden access to file',\n  404: 'Could not locate file',\n  408: 'Request timeout error occurred while trying to load file',\n  // 5xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)\n  500: 'Internal server error error occurred while trying to load file',\n  502: 'Bad gateway error occurred while trying to load file',\n  503: 'Service unavailable error occurred while trying to load file',\n  504: 'Gateway timeout error occurred while trying to load file'\n};\n/**\n * Helper method to handle fatal errors that occur while trying to load a file from the Hugging Face Hub.\n * @param {number} status The HTTP status code of the error.\n * @param {string} remoteURL The URL of the file that could not be loaded.\n * @param {boolean} fatal Whether to raise an error if the file could not be loaded.\n * @returns {null} Returns `null` if `fatal = true`.\n * @throws {Error} If `fatal = false`.\n */\nfunction handleError(status, remoteURL, fatal) {\n  if (!fatal) {\n    // File was not loaded correctly, but it is optional.\n    // TODO in future, cache the response?\n    return null;\n  }\n  const message = ERROR_MAPPING[status] ?? `Error (${status}) occurred while trying to load file`;\n  throw Error(`${message}: \"${remoteURL}\".`);\n}\nclass FileCache {\n  /**\n   * Instantiate a `FileCache` object.\n   * @param {string} path \n   */\n  constructor(path) {\n    this.path = path;\n  }\n\n  /**\n   * Checks whether the given request is in the cache.\n   * @param {string} request \n   * @returns {Promise<FileResponse | undefined>}\n   */\n  async match(request) {\n    let filePath = path.join(this.path, request);\n    let file = new FileResponse(filePath);\n    if (file.exists) {\n      return file;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Adds the given response to the cache.\n   * @param {string} request \n   * @param {Response|FileResponse} response \n   * @returns {Promise<void>}\n   */\n  async put(request, response) {\n    const buffer = Buffer.from(await response.arrayBuffer());\n    let outputPath = path.join(this.path, request);\n    try {\n      await fs.promises.mkdir(path.dirname(outputPath), {\n        recursive: true\n      });\n      await fs.promises.writeFile(outputPath, buffer);\n    } catch (err) {\n      console.warn('An error occurred while writing the file to cache:', err);\n    }\n  }\n\n  // TODO add the rest?\n  // addAll(requests: RequestInfo[]): Promise<void>;\n  // delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<boolean>;\n  // keys(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Request>>;\n  // match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>;\n  // matchAll(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Response>>;\n}\n\n/**\n * \n * @param {FileCache|Cache} cache The cache to search\n * @param {string[]} names The names of the item to search for\n * @returns {Promise<FileResponse|Response|undefined>} The item from the cache, or undefined if not found.\n */\nasync function tryCache(cache) {\n  for (var _len2 = arguments.length, names = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    names[_key2 - 1] = arguments[_key2];\n  }\n  for (let name of names) {\n    try {\n      let result = await cache.match(name);\n      if (result) return result;\n    } catch (e) {\n      continue;\n    }\n  }\n  return undefined;\n}\n\n/**\n * \n * Retrieves a file from either a remote URL using the Fetch API or from the local file system using the FileSystem API.\n * If the filesystem is available and `env.useCache = true`, the file will be downloaded and cached.\n * \n * @param {string} path_or_repo_id This can be either:\n * - a string, the *model id* of a model repo on huggingface.co.\n * - a path to a *directory* potentially containing the file.\n * @param {string} filename The name of the file to locate in `path_or_repo`.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * \n * @throws Will throw an error if the file is not found and `fatal` is true.\n * @returns {Promise} A Promise that resolves with the file content as a buffer.\n */\nexport async function getModelFile(path_or_repo_id, filename) {\n  let fatal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (!env.allowLocalModels) {\n    // User has disabled local models, so we just make sure other settings are correct.\n\n    if (options.local_files_only) {\n      throw Error(\"Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).\");\n    } else if (!env.allowRemoteModels) {\n      throw Error(\"Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.\");\n    }\n  }\n\n  // Initiate file retrieval\n  dispatchCallback(options.progress_callback, {\n    status: 'initiate',\n    name: path_or_repo_id,\n    file: filename\n  });\n\n  // First, check if the a caching backend is available\n  // If no caching mechanism available, will download the file every time\n  let cache;\n  if (!cache && env.useBrowserCache) {\n    if (typeof caches === 'undefined') {\n      throw Error('Browser cache is not available in this environment.');\n    }\n    try {\n      // In some cases, the browser cache may be visible, but not accessible due to security restrictions.\n      // For example, when running an application in an iframe, if a user attempts to load the page in\n      // incognito mode, the following error is thrown: `DOMException: Failed to execute 'open' on 'CacheStorage':\n      // An attempt was made to break through the security policy of the user agent.`\n      // So, instead of crashing, we just ignore the error and continue without using the cache.\n      cache = await caches.open('transformers-cache');\n    } catch (e) {\n      console.warn('An error occurred while opening the browser cache:', e);\n    }\n  }\n  if (!cache && env.useFSCache) {\n    // TODO throw error if not available\n\n    // If `cache_dir` is not specified, use the default cache directory\n    cache = new FileCache(options.cache_dir ?? env.cacheDir);\n  }\n  const revision = options.revision ?? 'main';\n  let requestURL = pathJoin(path_or_repo_id, filename);\n  let localPath = pathJoin(env.localModelPath, requestURL);\n  let remoteURL = pathJoin(env.remoteHost, env.remotePathTemplate.replaceAll('{model}', path_or_repo_id).replaceAll('{revision}', revision), filename);\n\n  // Choose cache key for filesystem cache\n  // When using the main revision (default), we use the request URL as the cache key.\n  // If a specific revision is requested, we account for this in the cache key.\n  let fsCacheKey = revision === 'main' ? requestURL : pathJoin(path_or_repo_id, revision, filename);\n\n  /** @type {string} */\n  let cacheKey;\n  let proposedCacheKey = cache instanceof FileCache ? fsCacheKey : remoteURL;\n\n  /** @type {Response|undefined} */\n  let responseToCache;\n\n  /** @type {Response|FileResponse|undefined} */\n  let response;\n  if (cache) {\n    // A caching system is available, so we try to get the file from it.\n    //  1. We first try to get from cache using the local path. In some environments (like deno),\n    //     non-URL cache keys are not allowed. In these cases, `response` will be undefined.\n    //  2. If no response is found, we try to get from cache using the remote URL or file system cache.\n    response = await tryCache(cache, localPath, proposedCacheKey);\n  }\n  if (response === undefined) {\n    // Caching not available, or file is not cached, so we perform the request\n\n    let isURL = isValidHttpUrl(requestURL);\n    if (env.allowLocalModels) {\n      // Accessing local models is enabled, so we try to get the file locally.\n      // If request is a valid HTTP URL, we skip the local file check. Otherwise, we try to get the file locally.\n      if (!isURL) {\n        try {\n          response = await getFile(localPath);\n          cacheKey = localPath; // Update the cache key to be the local path\n        } catch (e) {\n          // Something went wrong while trying to get the file locally.\n          // NOTE: error handling is done in the next step (since `response` will be undefined)\n          console.warn(`Unable to load from local path \"${localPath}\": \"${e}\"`);\n        }\n      } else if (options.local_files_only) {\n        throw new Error(`\\`local_files_only=true\\`, but attempted to load a remote file from: ${requestURL}.`);\n      } else if (!env.allowRemoteModels) {\n        throw new Error(`\\`env.allowRemoteModels=false\\`, but attempted to load a remote file from: ${requestURL}.`);\n      }\n    }\n    if (response === undefined || response.status === 404) {\n      // File not found locally. This means either:\n      // - The user has disabled local file access (`env.allowLocalModels=false`)\n      // - the path is a valid HTTP url (`response === undefined`)\n      // - the path is not a valid HTTP url and the file is not present on the file system or local server (`response.status === 404`)\n\n      if (options.local_files_only || !env.allowRemoteModels) {\n        // User requested local files only, but the file is not found locally.\n        if (fatal) {\n          throw Error(`\\`local_files_only=true\\` or \\`env.allowRemoteModels=false\\` and file was not found locally at \"${localPath}\".`);\n        } else {\n          // File not found, but this file is optional.\n          // TODO in future, cache the response?\n          return null;\n        }\n      }\n\n      // File not found locally, so we try to download it from the remote server\n      response = await getFile(remoteURL);\n      if (response.status !== 200) {\n        return handleError(response.status, remoteURL, fatal);\n      }\n\n      // Success! We use the proposed cache key from earlier\n      cacheKey = proposedCacheKey;\n    }\n    if (cache && response instanceof Response && response.status === 200) {\n      // only clone if cache available, and response is valid\n      responseToCache = response.clone();\n    }\n  }\n\n  // Start downloading\n  dispatchCallback(options.progress_callback, {\n    status: 'download',\n    name: path_or_repo_id,\n    file: filename\n  });\n  const buffer = await readResponse(response, data => {\n    dispatchCallback(options.progress_callback, {\n      status: 'progress',\n      ...data,\n      name: path_or_repo_id,\n      file: filename\n    });\n  });\n  if (\n  // Only cache web responses\n  // i.e., do not cache FileResponses (prevents duplication)\n  responseToCache && cacheKey &&\n  // Check again whether request is in cache. If not, we add the response to the cache\n  (await cache.match(cacheKey)) === undefined) {\n    await cache.put(cacheKey, responseToCache).catch(err => {\n      // Do not crash if unable to add to cache (e.g., QuotaExceededError).\n      // Rather, log a warning and proceed with execution.\n      console.warn(`Unable to add response to browser cache: ${err}.`);\n    });\n  }\n  dispatchCallback(options.progress_callback, {\n    status: 'done',\n    name: path_or_repo_id,\n    file: filename\n  });\n  return buffer;\n}\n\n/**\n * Fetches a JSON file from a given path and file name.\n *\n * @param {string} modelPath The path to the directory containing the file.\n * @param {string} fileName The name of the file to fetch.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * @returns {Promise<Object>} The JSON data parsed into a JavaScript object.\n * @throws Will throw an error if the file is not found and `fatal` is true.\n */\nexport async function getModelJSON(modelPath, fileName) {\n  let fatal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let buffer = await getModelFile(modelPath, fileName, fatal, options);\n  if (buffer === null) {\n    // Return empty object\n    return {};\n  }\n  let decoder = new TextDecoder('utf-8');\n  let jsonData = decoder.decode(buffer);\n  return JSON.parse(jsonData);\n}\n\n/**\n * Read and track progress when reading a Response object\n *\n * @param {any} response The Response object to read\n * @param {function} progress_callback The function to call with progress updates\n * @returns {Promise<Uint8Array>} A Promise that resolves with the Uint8Array buffer\n */\nasync function readResponse(response, progress_callback) {\n  // Read and track progress when reading a Response object\n\n  const contentLength = response.headers.get('Content-Length');\n  if (contentLength === null) {\n    console.warn('Unable to determine content-length from response headers. Will expand buffer when needed.');\n  }\n  let total = parseInt(contentLength ?? '0');\n  let buffer = new Uint8Array(total);\n  let loaded = 0;\n  const reader = response.body.getReader();\n  async function read() {\n    const {\n      done,\n      value\n    } = await reader.read();\n    if (done) return;\n    let newLoaded = loaded + value.length;\n    if (newLoaded > total) {\n      total = newLoaded;\n\n      // Adding the new data will overflow buffer.\n      // In this case, we extend the buffer\n      let newBuffer = new Uint8Array(total);\n\n      // copy contents\n      newBuffer.set(buffer);\n      buffer = newBuffer;\n    }\n    buffer.set(value, loaded);\n    loaded = newLoaded;\n    const progress = loaded / total * 100;\n\n    // Call your function here\n    progress_callback({\n      progress: progress,\n      loaded: loaded,\n      total: total\n    });\n    return read();\n  }\n\n  // Actually read\n  await read();\n  return buffer;\n}\n\n/**\n * Joins multiple parts of a path into a single path, while handling leading and trailing slashes.\n *\n * @param {...string} parts Multiple parts of a path.\n * @returns {string} A string representing the joined path.\n */\nfunction pathJoin() {\n  for (var _len3 = arguments.length, parts = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    parts[_key3] = arguments[_key3];\n  }\n  // https://stackoverflow.com/a/55142565\n  parts = parts.map((part, index) => {\n    if (index) {\n      part = part.replace(new RegExp('^/'), '');\n    }\n    if (index !== parts.length - 1) {\n      part = part.replace(new RegExp('/$'), '');\n    }\n    return part;\n  });\n  return parts.join('/');\n}","map":{"version":3,"names":["fs","path","stream","env","dispatchCallback","globalThis","ReadableStream","Headers","Object","constructor","_len","arguments","length","args","Array","_key","assign","get","key","clone","FileResponse","_CONTENT_TYPE_MAP","filePath","headers","exists","existsSync","status","statusText","stats","statSync","size","updateContentType","self","body","start","controller","arrayBuffer","then","buffer","enqueue","Uint8Array","close","extension","toString","split","pop","toLowerCase","response","data","promises","readFile","blob","Blob","type","text","json","JSON","parse","isValidHttpUrl","string","url","URL","_","protocol","getFile","urlOrPath","useFS","process","release","name","IS_CI","TESTING_REMOTELY","version","fetch","ERROR_MAPPING","handleError","remoteURL","fatal","message","Error","FileCache","match","request","join","file","undefined","put","Buffer","from","outputPath","mkdir","dirname","recursive","writeFile","err","console","warn","tryCache","cache","_len2","names","_key2","result","e","getModelFile","path_or_repo_id","filename","options","allowLocalModels","local_files_only","allowRemoteModels","progress_callback","useBrowserCache","caches","open","useFSCache","cache_dir","cacheDir","revision","requestURL","pathJoin","localPath","localModelPath","remoteHost","remotePathTemplate","replaceAll","fsCacheKey","cacheKey","proposedCacheKey","responseToCache","isURL","Response","readResponse","catch","getModelJSON","modelPath","fileName","decoder","TextDecoder","jsonData","decode","contentLength","total","parseInt","loaded","reader","getReader","read","done","value","newLoaded","newBuffer","set","progress","_len3","parts","_key3","map","part","index","replace","RegExp"],"sources":["/Users/phreetech13/Desktop/RealTimeAudioToText/node_modules/@xenova/transformers/src/utils/hub.js"],"sourcesContent":["\n/**\n * @file Utility functions to interact with the Hugging Face Hub (https://huggingface.co/models)\n * \n * @module utils/hub\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport stream from 'stream/web';\n\nimport { env } from '../env.js';\nimport { dispatchCallback } from './core.js';\n\nif (!globalThis.ReadableStream) {\n    // @ts-ignore\n    globalThis.ReadableStream = stream.ReadableStream; // ReadableStream is not a global with Node 16\n}\n\n/**\n * @typedef {Object} PretrainedOptions Options for loading a pretrained model.     \n * @property {boolean?} [options.quantized=true] Whether to load the 8-bit quantized version of the model (only applicable when loading model files).\n * @property {function} [options.progress_callback=null] If specified, this function will be called during model construction, to provide the user with progress updates.\n * @property {Object} [options.config=null] Configuration for the model to use instead of an automatically loaded configuration. Configuration can be automatically loaded when:\n * - The model is a model provided by the library (loaded with the *model id* string of a pretrained model).\n * - The model is loaded by supplying a local directory as `pretrained_model_name_or_path` and a configuration JSON file named *config.json* is found in the directory.\n * @property {string} [options.cache_dir=null] Path to a directory in which a downloaded pretrained model configuration should be cached if the standard cache should not be used.\n * @property {boolean} [options.local_files_only=false] Whether or not to only look at local files (e.g., not try downloading the model).\n * @property {string} [options.revision='main'] The specific model version to use. It can be a branch name, a tag name, or a commit id,\n * since we use a git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any identifier allowed by git.\n * NOTE: This setting is ignored for local requests.\n */\n\nclass Headers extends Object {\n    constructor(...args) {\n        super();\n        Object.assign(this, args);\n    }\n\n    get(key) {\n        return this[key];\n    }\n\n    clone() {\n        return new Headers(this);\n    }\n}\n\nclass FileResponse {\n    /**\n     * Mapping from file extensions to MIME types.\n     */\n    _CONTENT_TYPE_MAP = {\n        'txt': 'text/plain',\n        'html': 'text/html',\n        'css': 'text/css',\n        'js': 'text/javascript',\n        'json': 'application/json',\n        'png': 'image/png',\n        'jpg': 'image/jpeg',\n        'jpeg': 'image/jpeg',\n        'gif': 'image/gif',\n    }\n    /**\n     * Creates a new `FileResponse` object.\n     * @param {string|URL} filePath\n     */\n    constructor(filePath) {\n        this.filePath = filePath;\n        this.headers = new Headers();\n\n        this.exists = fs.existsSync(filePath);\n        if (this.exists) {\n            this.status = 200;\n            this.statusText = 'OK';\n\n            let stats = fs.statSync(filePath);\n            this.headers['content-length'] = stats.size;\n\n            this.updateContentType();\n\n            let self = this;\n            this.body = new ReadableStream({\n                start(controller) {\n                    self.arrayBuffer().then(buffer => {\n                        controller.enqueue(new Uint8Array(buffer));\n                        controller.close();\n                    })\n                }\n            });\n        } else {\n            this.status = 404;\n            this.statusText = 'Not Found';\n            this.body = null;\n        }\n    }\n\n    /**\n     * Updates the 'content-type' header property of the response based on the extension of\n     * the file specified by the filePath property of the current object.\n     * @returns {void}\n     */\n    updateContentType() {\n        // Set content-type header based on file extension\n        const extension = this.filePath.toString().split('.').pop().toLowerCase();\n        this.headers['content-type'] = this._CONTENT_TYPE_MAP[extension] ?? 'application/octet-stream';\n    }\n\n    /**\n     * Clone the current FileResponse object.\n     * @returns {FileResponse} A new FileResponse object with the same properties as the current object.\n     */\n    clone() {\n        let response = new FileResponse(this.filePath);\n        response.exists = this.exists;\n        response.status = this.status;\n        response.statusText = this.statusText;\n        response.headers = this.headers.clone();\n        return response;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with an ArrayBuffer containing the file's contents.\n     * @returns {Promise<ArrayBuffer>} A Promise that resolves with an ArrayBuffer containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async arrayBuffer() {\n        const data = await fs.promises.readFile(this.filePath);\n        return data.buffer;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a Blob containing the file's contents.\n     * @returns {Promise<Blob>} A Promise that resolves with a Blob containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async blob() {\n        const data = await fs.promises.readFile(this.filePath);\n        return new Blob([data], { type: this.headers['content-type'] });\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a string containing the file's contents.\n     * @returns {Promise<string>} A Promise that resolves with a string containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async text() {\n        const data = await fs.promises.readFile(this.filePath, 'utf8');\n        return data;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a parsed JavaScript object containing the file's contents.\n     * \n     * @returns {Promise<Object>} A Promise that resolves with a parsed JavaScript object containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async json() {\n        return JSON.parse(await this.text());\n    }\n}\n\n/**\n * Determines whether the given string is a valid HTTP or HTTPS URL.\n * @param {string|URL} string The string to test for validity as an HTTP or HTTPS URL.\n * @returns {boolean} True if the string is a valid HTTP or HTTPS URL, false otherwise.\n */\nfunction isValidHttpUrl(string) {\n    // https://stackoverflow.com/a/43467144\n    let url;\n    try {\n        url = new URL(string);\n    } catch (_) {\n        return false;\n    }\n    return url.protocol === \"http:\" || url.protocol === \"https:\";\n}\n\n/**\n * Helper function to get a file, using either the Fetch API or FileSystem API.\n *\n * @param {URL|string} urlOrPath The URL/path of the file to get.\n * @returns {Promise<FileResponse|Response>} A promise that resolves to a FileResponse object (if the file is retrieved using the FileSystem API), or a Response object (if the file is retrieved using the Fetch API).\n */\nexport async function getFile(urlOrPath) {\n\n    if (env.useFS && !isValidHttpUrl(urlOrPath)) {\n        return new FileResponse(urlOrPath);\n\n    } else if (typeof process !== 'undefined' && process?.release?.name === 'node') {\n        const IS_CI = !!process.env?.TESTING_REMOTELY;\n        const version = env.version;\n        return fetch(urlOrPath, {\n            headers: {\n                'User-Agent': `transformers.js/${version}; is_ci/${IS_CI};`\n            }\n        });\n    } else {\n        // Running in a browser-environment, so we use default headers\n        return fetch(urlOrPath);\n    }\n}\n\nconst ERROR_MAPPING = {\n    // 4xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)\n    400: 'Bad request error occurred while trying to load file',\n    401: 'Unauthorized access to file',\n    403: 'Forbidden access to file',\n    404: 'Could not locate file',\n    408: 'Request timeout error occurred while trying to load file',\n\n    // 5xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)\n    500: 'Internal server error error occurred while trying to load file',\n    502: 'Bad gateway error occurred while trying to load file',\n    503: 'Service unavailable error occurred while trying to load file',\n    504: 'Gateway timeout error occurred while trying to load file',\n}\n/**\n * Helper method to handle fatal errors that occur while trying to load a file from the Hugging Face Hub.\n * @param {number} status The HTTP status code of the error.\n * @param {string} remoteURL The URL of the file that could not be loaded.\n * @param {boolean} fatal Whether to raise an error if the file could not be loaded.\n * @returns {null} Returns `null` if `fatal = true`.\n * @throws {Error} If `fatal = false`.\n */\nfunction handleError(status, remoteURL, fatal) {\n    if (!fatal) {\n        // File was not loaded correctly, but it is optional.\n        // TODO in future, cache the response?\n        return null;\n    }\n\n    const message = ERROR_MAPPING[status] ?? `Error (${status}) occurred while trying to load file`;\n    throw Error(`${message}: \"${remoteURL}\".`);\n}\n\nclass FileCache {\n    /**\n     * Instantiate a `FileCache` object.\n     * @param {string} path \n     */\n    constructor(path) {\n        this.path = path;\n    }\n\n    /**\n     * Checks whether the given request is in the cache.\n     * @param {string} request \n     * @returns {Promise<FileResponse | undefined>}\n     */\n    async match(request) {\n\n        let filePath = path.join(this.path, request);\n        let file = new FileResponse(filePath);\n\n        if (file.exists) {\n            return file;\n        } else {\n            return undefined;\n        }\n    }\n\n    /**\n     * Adds the given response to the cache.\n     * @param {string} request \n     * @param {Response|FileResponse} response \n     * @returns {Promise<void>}\n     */\n    async put(request, response) {\n        const buffer = Buffer.from(await response.arrayBuffer());\n\n        let outputPath = path.join(this.path, request);\n\n        try {\n            await fs.promises.mkdir(path.dirname(outputPath), { recursive: true });\n            await fs.promises.writeFile(outputPath, buffer);\n\n        } catch (err) {\n            console.warn('An error occurred while writing the file to cache:', err)\n        }\n    }\n\n    // TODO add the rest?\n    // addAll(requests: RequestInfo[]): Promise<void>;\n    // delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<boolean>;\n    // keys(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Request>>;\n    // match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>;\n    // matchAll(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Response>>;\n}\n\n/**\n * \n * @param {FileCache|Cache} cache The cache to search\n * @param {string[]} names The names of the item to search for\n * @returns {Promise<FileResponse|Response|undefined>} The item from the cache, or undefined if not found.\n */\nasync function tryCache(cache, ...names) {\n    for (let name of names) {\n        try {\n            let result = await cache.match(name);\n            if (result) return result;\n        } catch (e) {\n            continue;\n        }\n    }\n    return undefined;\n}\n\n/**\n * \n * Retrieves a file from either a remote URL using the Fetch API or from the local file system using the FileSystem API.\n * If the filesystem is available and `env.useCache = true`, the file will be downloaded and cached.\n * \n * @param {string} path_or_repo_id This can be either:\n * - a string, the *model id* of a model repo on huggingface.co.\n * - a path to a *directory* potentially containing the file.\n * @param {string} filename The name of the file to locate in `path_or_repo`.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * \n * @throws Will throw an error if the file is not found and `fatal` is true.\n * @returns {Promise} A Promise that resolves with the file content as a buffer.\n */\nexport async function getModelFile(path_or_repo_id, filename, fatal = true, options = {}) {\n\n    if (!env.allowLocalModels) {\n        // User has disabled local models, so we just make sure other settings are correct.\n\n        if (options.local_files_only) {\n            throw Error(\"Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).\")\n        } else if (!env.allowRemoteModels) {\n            throw Error(\"Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.\")\n        }\n    }\n\n    // Initiate file retrieval\n    dispatchCallback(options.progress_callback, {\n        status: 'initiate',\n        name: path_or_repo_id,\n        file: filename\n    })\n\n    // First, check if the a caching backend is available\n    // If no caching mechanism available, will download the file every time\n    let cache;\n    if (!cache && env.useBrowserCache) {\n        if (typeof caches === 'undefined') {\n            throw Error('Browser cache is not available in this environment.')\n        }\n        try {\n            // In some cases, the browser cache may be visible, but not accessible due to security restrictions.\n            // For example, when running an application in an iframe, if a user attempts to load the page in\n            // incognito mode, the following error is thrown: `DOMException: Failed to execute 'open' on 'CacheStorage':\n            // An attempt was made to break through the security policy of the user agent.`\n            // So, instead of crashing, we just ignore the error and continue without using the cache.\n            cache = await caches.open('transformers-cache');\n        } catch (e) {\n            console.warn('An error occurred while opening the browser cache:', e);\n        }\n    }\n\n    if (!cache && env.useFSCache) {\n        // TODO throw error if not available\n\n        // If `cache_dir` is not specified, use the default cache directory\n        cache = new FileCache(options.cache_dir ?? env.cacheDir);\n    }\n\n    const revision = options.revision ?? 'main';\n\n    let requestURL = pathJoin(path_or_repo_id, filename);\n    let localPath = pathJoin(env.localModelPath, requestURL);\n\n    let remoteURL = pathJoin(\n        env.remoteHost,\n        env.remotePathTemplate\n            .replaceAll('{model}', path_or_repo_id)\n            .replaceAll('{revision}', revision),\n        filename\n    );\n\n    // Choose cache key for filesystem cache\n    // When using the main revision (default), we use the request URL as the cache key.\n    // If a specific revision is requested, we account for this in the cache key.\n    let fsCacheKey = revision === 'main' ? requestURL : pathJoin(path_or_repo_id, revision, filename);\n\n    /** @type {string} */\n    let cacheKey;\n    let proposedCacheKey = cache instanceof FileCache ? fsCacheKey : remoteURL;\n\n    /** @type {Response|undefined} */\n    let responseToCache;\n\n    /** @type {Response|FileResponse|undefined} */\n    let response;\n\n    if (cache) {\n        // A caching system is available, so we try to get the file from it.\n        //  1. We first try to get from cache using the local path. In some environments (like deno),\n        //     non-URL cache keys are not allowed. In these cases, `response` will be undefined.\n        //  2. If no response is found, we try to get from cache using the remote URL or file system cache.\n        response = await tryCache(cache, localPath, proposedCacheKey);\n    }\n\n    if (response === undefined) {\n        // Caching not available, or file is not cached, so we perform the request\n\n        let isURL = isValidHttpUrl(requestURL);\n\n        if (env.allowLocalModels) {\n            // Accessing local models is enabled, so we try to get the file locally.\n            // If request is a valid HTTP URL, we skip the local file check. Otherwise, we try to get the file locally.\n            if (!isURL) {\n                try {\n                    response = await getFile(localPath);\n                    cacheKey = localPath; // Update the cache key to be the local path\n                } catch (e) {\n                    // Something went wrong while trying to get the file locally.\n                    // NOTE: error handling is done in the next step (since `response` will be undefined)\n                    console.warn(`Unable to load from local path \"${localPath}\": \"${e}\"`);\n                }\n            } else if (options.local_files_only) {\n                throw new Error(`\\`local_files_only=true\\`, but attempted to load a remote file from: ${requestURL}.`);\n            } else if (!env.allowRemoteModels) {\n                throw new Error(`\\`env.allowRemoteModels=false\\`, but attempted to load a remote file from: ${requestURL}.`);\n            }\n        }\n\n        if (response === undefined || response.status === 404) {\n            // File not found locally. This means either:\n            // - The user has disabled local file access (`env.allowLocalModels=false`)\n            // - the path is a valid HTTP url (`response === undefined`)\n            // - the path is not a valid HTTP url and the file is not present on the file system or local server (`response.status === 404`)\n\n            if (options.local_files_only || !env.allowRemoteModels) {\n                // User requested local files only, but the file is not found locally.\n                if (fatal) {\n                    throw Error(`\\`local_files_only=true\\` or \\`env.allowRemoteModels=false\\` and file was not found locally at \"${localPath}\".`);\n                } else {\n                    // File not found, but this file is optional.\n                    // TODO in future, cache the response?\n                    return null;\n                }\n            }\n\n            // File not found locally, so we try to download it from the remote server\n            response = await getFile(remoteURL);\n\n            if (response.status !== 200) {\n                return handleError(response.status, remoteURL, fatal);\n            }\n\n            // Success! We use the proposed cache key from earlier\n            cacheKey = proposedCacheKey;\n        }\n\n\n        if (cache && response instanceof Response && response.status === 200) {\n            // only clone if cache available, and response is valid\n            responseToCache = response.clone();\n        }\n    }\n\n\n    // Start downloading\n    dispatchCallback(options.progress_callback, {\n        status: 'download',\n        name: path_or_repo_id,\n        file: filename\n    })\n\n    const buffer = await readResponse(response, data => {\n        dispatchCallback(options.progress_callback, {\n            status: 'progress',\n            ...data,\n            name: path_or_repo_id,\n            file: filename\n        })\n    })\n\n\n    if (\n        // Only cache web responses\n        // i.e., do not cache FileResponses (prevents duplication)\n        responseToCache && cacheKey\n        &&\n        // Check again whether request is in cache. If not, we add the response to the cache\n        (await cache.match(cacheKey) === undefined)\n    ) {\n        await cache.put(cacheKey, responseToCache)\n            .catch(err => {\n                // Do not crash if unable to add to cache (e.g., QuotaExceededError).\n                // Rather, log a warning and proceed with execution.\n                console.warn(`Unable to add response to browser cache: ${err}.`);\n            });\n\n    }\n\n    dispatchCallback(options.progress_callback, {\n        status: 'done',\n        name: path_or_repo_id,\n        file: filename\n    });\n\n    return buffer;\n}\n\n/**\n * Fetches a JSON file from a given path and file name.\n *\n * @param {string} modelPath The path to the directory containing the file.\n * @param {string} fileName The name of the file to fetch.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * @returns {Promise<Object>} The JSON data parsed into a JavaScript object.\n * @throws Will throw an error if the file is not found and `fatal` is true.\n */\nexport async function getModelJSON(modelPath, fileName, fatal = true, options = {}) {\n    let buffer = await getModelFile(modelPath, fileName, fatal, options);\n    if (buffer === null) {\n        // Return empty object\n        return {}\n    }\n\n    let decoder = new TextDecoder('utf-8');\n    let jsonData = decoder.decode(buffer);\n\n    return JSON.parse(jsonData);\n}\n\n/**\n * Read and track progress when reading a Response object\n *\n * @param {any} response The Response object to read\n * @param {function} progress_callback The function to call with progress updates\n * @returns {Promise<Uint8Array>} A Promise that resolves with the Uint8Array buffer\n */\nasync function readResponse(response, progress_callback) {\n    // Read and track progress when reading a Response object\n\n    const contentLength = response.headers.get('Content-Length');\n    if (contentLength === null) {\n        console.warn('Unable to determine content-length from response headers. Will expand buffer when needed.')\n    }\n    let total = parseInt(contentLength ?? '0');\n    let buffer = new Uint8Array(total);\n    let loaded = 0;\n\n    const reader = response.body.getReader();\n    async function read() {\n        const { done, value } = await reader.read();\n        if (done) return;\n\n        let newLoaded = loaded + value.length;\n        if (newLoaded > total) {\n            total = newLoaded;\n\n            // Adding the new data will overflow buffer.\n            // In this case, we extend the buffer\n            let newBuffer = new Uint8Array(total);\n\n            // copy contents\n            newBuffer.set(buffer);\n\n            buffer = newBuffer;\n        }\n        buffer.set(value, loaded)\n        loaded = newLoaded;\n\n        const progress = (loaded / total) * 100;\n\n        // Call your function here\n        progress_callback({\n            progress: progress,\n            loaded: loaded,\n            total: total,\n        })\n\n        return read();\n    }\n\n    // Actually read\n    await read();\n\n    return buffer;\n}\n\n/**\n * Joins multiple parts of a path into a single path, while handling leading and trailing slashes.\n *\n * @param {...string} parts Multiple parts of a path.\n * @returns {string} A string representing the joined path.\n */\nfunction pathJoin(...parts) {\n    // https://stackoverflow.com/a/55142565\n    parts = parts.map((part, index) => {\n        if (index) {\n            part = part.replace(new RegExp('^/'), '');\n        }\n        if (index !== parts.length - 1) {\n            part = part.replace(new RegExp('/$'), '');\n        }\n        return part;\n    })\n    return parts.join('/');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}