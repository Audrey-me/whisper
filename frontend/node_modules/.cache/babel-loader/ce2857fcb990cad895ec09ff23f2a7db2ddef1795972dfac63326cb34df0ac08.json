{"ast":null,"code":"/**\n * @file Helper module for mathematical processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/maths\n */\n\n/**\n * @typedef {Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array} TypedArray\n * @typedef {BigInt64Array | BigUint64Array} BigTypedArray\n * @typedef {TypedArray | BigTypedArray} AnyTypedArray\n */\n\n/**\n * @param {TypedArray} input\n */\nexport function interpolate_data(input, _ref, _ref2) {\n  let [in_channels, in_height, in_width] = _ref;\n  let [out_height, out_width] = _ref2;\n  let mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'bilinear';\n  let align_corners = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  // TODO use mode and align_corners\n\n  // Output image dimensions\n  const x_scale = out_width / in_width;\n  const y_scale = out_height / in_height;\n\n  // Output image\n  // @ts-ignore\n  const out_img = new input.constructor(out_height * out_width * in_channels);\n\n  // Pre-calculate strides\n  const inStride = in_height * in_width;\n  const outStride = out_height * out_width;\n  for (let i = 0; i < out_height; ++i) {\n    for (let j = 0; j < out_width; ++j) {\n      // Calculate output offset\n      const outOffset = i * out_width + j;\n\n      // Calculate input pixel coordinates\n      const x = (j + 0.5) / x_scale - 0.5;\n      const y = (i + 0.5) / y_scale - 0.5;\n\n      // Calculate the four nearest input pixels\n      // We also check if the input pixel coordinates are within the image bounds\n      let x1 = Math.floor(x);\n      let y1 = Math.floor(y);\n      const x2 = Math.min(x1 + 1, in_width - 1);\n      const y2 = Math.min(y1 + 1, in_height - 1);\n      x1 = Math.max(x1, 0);\n      y1 = Math.max(y1, 0);\n\n      // Calculate the fractional distances between the input pixel and the four nearest pixels\n      const s = x - x1;\n      const t = y - y1;\n\n      // Perform bilinear interpolation\n      const w1 = (1 - s) * (1 - t);\n      const w2 = s * (1 - t);\n      const w3 = (1 - s) * t;\n      const w4 = s * t;\n\n      // Calculate the four nearest input pixel indices\n      const yStride = y1 * in_width;\n      const xStride = y2 * in_width;\n      const idx1 = yStride + x1;\n      const idx2 = yStride + x2;\n      const idx3 = xStride + x1;\n      const idx4 = xStride + x2;\n      for (let k = 0; k < in_channels; ++k) {\n        // Calculate channel offset\n        const cOffset = k * inStride;\n        out_img[k * outStride + outOffset] = w1 * input[cOffset + idx1] + w2 * input[cOffset + idx2] + w3 * input[cOffset + idx3] + w4 * input[cOffset + idx4];\n      }\n    }\n  }\n  return out_img;\n}\n\n/**\n * Helper method to transpose a `AnyTypedArray` directly\n * @param {T} array \n * @template {AnyTypedArray} T \n * @param {number[]} dims \n * @param {number[]} axes \n * @returns {[T, number[]]} The transposed array and the new shape.\n */\nexport function transpose_data(array, dims, axes) {\n  // Calculate the new shape of the transposed array\n  // and the stride of the original array\n  const shape = new Array(axes.length);\n  const stride = new Array(axes.length);\n  for (let i = axes.length - 1, s = 1; i >= 0; --i) {\n    stride[i] = s;\n    shape[i] = dims[axes[i]];\n    s *= shape[i];\n  }\n\n  // Precompute inverse mapping of stride\n  const invStride = axes.map((_, i) => stride[axes.indexOf(i)]);\n\n  // Create the transposed array with the new shape\n  // @ts-ignore\n  const transposedData = new array.constructor(array.length);\n\n  // Transpose the original array to the new array\n  for (let i = 0; i < array.length; ++i) {\n    let newIndex = 0;\n    for (let j = dims.length - 1, k = i; j >= 0; --j) {\n      newIndex += k % dims[j] * invStride[j];\n      k = Math.floor(k / dims[j]);\n    }\n    transposedData[newIndex] = array[i];\n  }\n  return [transposedData, shape];\n}\n\n/**\n * Compute the softmax of an array of numbers.\n *\n * @param {number[]} arr The array of numbers to compute the softmax of.\n * @returns {number[]} The softmax array.\n */\nexport function softmax(arr) {\n  // Compute the maximum value in the array\n  const maxVal = max(arr)[0];\n\n  // Compute the exponentials of the array values\n  const exps = arr.map(x => Math.exp(x - maxVal));\n\n  // Compute the sum of the exponentials\n  const sumExps = exps.reduce((acc, val) => acc + val, 0);\n\n  // Compute the softmax values\n  const softmaxArr = exps.map(x => x / sumExps);\n  return softmaxArr;\n}\n\n/**\n * Calculates the logarithm of the softmax function for the input array.\n * @param {number[]} arr The input array to calculate the log_softmax function for.\n * @returns {any} The resulting log_softmax array.\n */\nexport function log_softmax(arr) {\n  // Compute the softmax values\n  const softmaxArr = softmax(arr);\n\n  // Apply log formula to each element\n  const logSoftmaxArr = softmaxArr.map(x => Math.log(x));\n  return logSoftmaxArr;\n}\n\n/**\n * Calculates the dot product of two arrays.\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The dot product of arr1 and arr2.\n */\nexport function dot(arr1, arr2) {\n  return arr1.reduce((acc, val, i) => acc + val * arr2[i], 0);\n}\n\n/**\n * Get the top k items from an iterable, sorted by descending order\n *\n * @param {Array} items The items to be sorted\n * @param {number} [top_k=0] The number of top items to return (default: 0 = return all)\n * @returns {Array} The top k items, sorted by descending order\n */\nexport function getTopItems(items) {\n  let top_k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // if top == 0, return all\n\n  items = Array.from(items).map((x, i) => [i, x]) // Get indices ([index, score])\n  .sort((a, b) => b[1] - a[1]); // Sort by log probabilities\n\n  if (top_k > 0) {\n    items = items.slice(0, top_k); // Get top k items\n  }\n\n  return items;\n}\n\n/**\n * Computes the cosine similarity between two arrays.\n *\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The cosine similarity between the two arrays.\n */\nexport function cos_sim(arr1, arr2) {\n  // Calculate dot product of the two arrays\n  const dotProduct = dot(arr1, arr2);\n\n  // Calculate the magnitude of the first array\n  const magnitudeA = magnitude(arr1);\n\n  // Calculate the magnitude of the second array\n  const magnitudeB = magnitude(arr2);\n\n  // Calculate the cosine similarity\n  const cosineSimilarity = dotProduct / (magnitudeA * magnitudeB);\n  return cosineSimilarity;\n}\n\n/**\n * Calculates the magnitude of a given array.\n * @param {number[]} arr The array to calculate the magnitude of.\n * @returns {number} The magnitude of the array.\n */\nexport function magnitude(arr) {\n  return Math.sqrt(arr.reduce((acc, val) => acc + val * val, 0));\n}\n\n/**\n * Returns the value and index of the minimum element in an array.\n * @param {number[]} arr array of numbers.\n * @returns {number[]} the value and index of the minimum element, of the form: [valueOfMin, indexOfMin]\n * @throws {Error} If array is empty.\n */\nexport function min(arr) {\n  if (arr.length === 0) throw Error('Array must not be empty');\n  let min = arr[0];\n  let indexOfMin = 0;\n  for (let i = 1; i < arr.length; ++i) {\n    if (arr[i] < min) {\n      min = arr[i];\n      indexOfMin = i;\n    }\n  }\n  return [min, indexOfMin];\n}\n\n/**\n * Returns the value and index of the maximum element in an array.\n * @param {number[]} arr array of numbers.\n * @returns {number[]} the value and index of the maximum element, of the form: [valueOfMax, indexOfMax]\n * @throws {Error} If array is empty.\n */\nexport function max(arr) {\n  if (arr.length === 0) throw Error('Array must not be empty');\n  let max = arr[0];\n  let indexOfMax = 0;\n  for (let i = 1; i < arr.length; ++i) {\n    if (arr[i] > max) {\n      max = arr[i];\n      indexOfMax = i;\n    }\n  }\n  return [max, indexOfMax];\n}\n\n/**\n * Return the Discrete Fourier Transform sample frequencies.\n * \n * Code adapted from https://github.com/numpy/numpy/blob/25908cacd19915bf3ddd659c28be28a41bd97a54/numpy/fft/helper.py#L173-L221\n * Original Python doc: https://numpy.org/doc/stable/reference/generated/numpy.fft.rfftfreq.html\n * @example\n * rfftfreq(400, 1 / 16000) // (201)Â [0, 40, 80, 120, 160, 200, ..., 8000]\n * @param {number} n Window length\n * @param {number} [d = 1.0] Sample spacing (inverse of the sampling rate). Defaults to 1.\n * @throws {TypeError} If n is not an integer.\n * @returns {number[]} Array of length `Math.floor(n / 2) + 1;` containing the sample frequencies.\n */\nexport function rfftfreq(n) {\n  let d = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;\n  if (!Number.isInteger(n)) {\n    throw new TypeError(`n should be an integer, but ${n} given.`);\n  }\n  const val = 1.0 / (n * d);\n  const len = Math.floor(n / 2) + 1;\n  const results = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    results[i] = i * val;\n  }\n  return results;\n}\n\n/**\n * FFT class provides functionality for performing Fast Fourier Transform on arrays\n * Code adapted from https://www.npmjs.com/package/fft.js\n */\nexport class FFT {\n  /**\n   * @param {number} size The size of the input array. Must be a power of two and bigger than 1.\n   * @throws {Error} FFT size must be a power of two and bigger than 1.\n   */\n  constructor(size) {\n    this.size = size | 0; // convert to a 32-bit signed integer\n    if (this.size <= 1 || (this.size & this.size - 1) !== 0) throw new Error('FFT size must be a power of two and bigger than 1');\n    this._csize = size << 1;\n    this.table = new Float32Array(this.size * 2);\n    for (let i = 0; i < this.table.length; i += 2) {\n      const angle = Math.PI * i / this.size;\n      this.table[i] = Math.cos(angle);\n      this.table[i + 1] = -Math.sin(angle);\n    }\n\n    // Find size's power of two\n    let power = 0;\n    for (let t = 1; this.size > t; t <<= 1) ++power;\n\n    // Calculate initial step's width:\n    //   * If we are full radix-4, it is 2x smaller to give inital len=8\n    //   * Otherwise it is the same as `power` to give len=4\n    this._width = power % 2 === 0 ? power - 1 : power;\n\n    // Pre-compute bit-reversal patterns\n    this._bitrev = new Int32Array(1 << this._width);\n    for (let j = 0; j < this._bitrev.length; ++j) {\n      this._bitrev[j] = 0;\n      for (let shift = 0; shift < this._width; shift += 2) {\n        const revShift = this._width - shift - 2;\n        this._bitrev[j] |= (j >>> shift & 3) << revShift;\n      }\n    }\n  }\n\n  /**\n   * Create a complex number array with size `2 * size`\n   *\n   * @returns {Float32Array} A complex number array with size `2 * size`\n   */\n  createComplexArray() {\n    return new Float32Array(this._csize);\n  }\n\n  /**\n   * Converts a complex number representation stored in a Float32Array to an array of real numbers.\n   * \n   * @param {Float32Array} complex The complex number representation to be converted.\n   * @param {number[]} [storage] An optional array to store the result in.\n   * @returns {number[]} An array of real numbers representing the input complex number representation.\n   */\n  fromComplexArray(complex, storage) {\n    const res = storage || new Array(complex.length >>> 1);\n    for (let i = 0; i < complex.length; i += 2) res[i >>> 1] = complex[i];\n    return res;\n  }\n\n  /**\n   * Convert a real-valued input array to a complex-valued output array.\n   * @param {Float32Array} input The real-valued input array.\n   * @param {Float32Array} [storage] Optional buffer to store the output array.\n   * @returns {Float32Array} The complex-valued output array.\n   */\n  toComplexArray(input, storage) {\n    const res = storage || this.createComplexArray();\n    for (let i = 0; i < res.length; i += 2) {\n      res[i] = input[i >>> 1];\n      res[i + 1] = 0;\n    }\n    return res;\n  }\n\n  /**\n   * Completes the spectrum by adding its mirrored negative frequency components.\n   * @param {Float32Array} spectrum The input spectrum.\n   * @returns {void}\n   */\n  completeSpectrum(spectrum) {\n    const size = this._csize;\n    const half = size >>> 1;\n    for (let i = 2; i < half; i += 2) {\n      spectrum[size - i] = spectrum[i];\n      spectrum[size - i + 1] = -spectrum[i + 1];\n    }\n  }\n\n  /**\n   * Performs a Fast Fourier Transform (FFT) on the given input data and stores the result in the output buffer.\n   * \n   * @param {Float32Array} out The output buffer to store the result.\n   * @param {Float32Array} data The input data to transform.\n   * \n   * @throws {Error} Input and output buffers must be different.\n   * \n   * @returns {void}\n   */\n  transform(out, data) {\n    if (out === data) throw new Error('Input and output buffers must be different');\n    this._transform4(out, data, 1 /* DONE */);\n  }\n\n  /**\n   * Performs a real-valued forward FFT on the given input buffer and stores the result in the given output buffer.\n   * The input buffer must contain real values only, while the output buffer will contain complex values. The input and\n   * output buffers must be different.\n   *\n   * @param {Float32Array} out The output buffer.\n   * @param {Float32Array} data The input buffer containing real values.\n   *\n   * @throws {Error} If the input and output buffers are the same.\n   */\n  realTransform(out, data) {\n    if (out === data) throw new Error('Input and output buffers must be different');\n    this._realTransform4(out, data, 1 /* DONE */);\n  }\n\n  /**\n   * Performs an inverse FFT transformation on the given `data` array, and stores the result in `out`.\n   * The `out` array must be a different buffer than the `data` array. The `out` array will contain the\n   * result of the transformation. The `data` array will not be modified.\n   * \n   * @param {Float32Array} out The output buffer for the transformed data.\n   * @param {Float32Array} data The input data to transform.\n   * @throws {Error} If `out` and `data` refer to the same buffer.\n   * @returns {void}\n   */\n  inverseTransform(out, data) {\n    if (out === data) throw new Error('Input and output buffers must be different');\n    this._transform4(out, data, -1 /* DONE */);\n    for (let i = 0; i < out.length; ++i) out[i] /= this.size;\n  }\n\n  /**\n   * Performs a radix-4 implementation of a discrete Fourier transform on a given set of data.\n   *\n   * @param {Float32Array} out The output buffer for the transformed data.\n   * @param {Float32Array} data The input buffer of data to be transformed.\n   * @param {number} inv A scaling factor to apply to the transform.\n   * @returns {void}\n   */\n  _transform4(out, data, inv) {\n    // radix-4 implementation\n\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    let outOff;\n    let t;\n    let bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n        const off = bitrev[t];\n        this._singleTransform2(data, out, outOff, off, step);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n        const off = bitrev[t];\n        this._singleTransform4(data, out, outOff, off, step, inv);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      let quarterLen = len >>> 2;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        // Full case\n        let limit = outOff + quarterLen;\n        for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n          const A = i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n          const tableBr = this.table[k];\n          const tableBi = inv * this.table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = this.table[2 * k];\n          const tableCi = inv * this.table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = this.table[3 * k];\n          const tableDi = inv * this.table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = Ar + MCr;\n          const T0i = Ai + MCi;\n          const T1r = Ar - MCr;\n          const T1i = Ai - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          out[A] = T0r + T2r;\n          out[A + 1] = T0i + T2i;\n          out[B] = T1r + T3i;\n          out[B + 1] = T1i - T3r;\n          out[C] = T0r - T2r;\n          out[C + 1] = T0i - T2i;\n          out[D] = T1r - T3i;\n          out[D + 1] = T1i + T3r;\n        }\n      }\n    }\n  }\n\n  /**\n   * Performs a radix-2 implementation of a discrete Fourier transform on a given set of data.\n   *\n   * @param {Float32Array} data The input buffer of data to be transformed.\n   * @param {Float32Array} out The output buffer for the transformed data.\n   * @param {number} outOff The offset at which to write the output data.\n   * @param {number} off The offset at which to begin reading the input data.\n   * @param {number} step The step size for indexing the input data.\n   * @returns {void}\n   */\n  _singleTransform2(data, out, outOff, off, step) {\n    // radix-2 implementation\n    // NOTE: Only called for len=4\n\n    const evenR = data[off];\n    const evenI = data[off + 1];\n    const oddR = data[off + step];\n    const oddI = data[off + step + 1];\n    out[outOff] = evenR + oddR;\n    out[outOff + 1] = evenI + oddI;\n    out[outOff + 2] = evenR - oddR;\n    out[outOff + 3] = evenI - oddI;\n  }\n\n  /**\n   * Performs radix-4 transformation on input data of length 8\n   *\n   * @param {Float32Array} data Input data array of length 8\n   * @param {Float32Array} out Output data array of length 8\n   * @param {number} outOff Index of output array to start writing from\n   * @param {number} off Index of input array to start reading from\n   * @param {number} step Step size between elements in input array\n   * @param {number} inv Scaling factor for inverse transform\n   * \n   * @returns {void}\n   */\n  _singleTransform4(data, out, outOff, off, step, inv) {\n    // radix-4\n    // NOTE: Only called for len=8\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Ai = data[off + 1];\n    const Br = data[off + step];\n    const Bi = data[off + step + 1];\n    const Cr = data[off + step2];\n    const Ci = data[off + step2 + 1];\n    const Dr = data[off + step3];\n    const Di = data[off + step3 + 1];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T0i = Ai + Ci;\n    const T1r = Ar - Cr;\n    const T1i = Ai - Ci;\n    const T2r = Br + Dr;\n    const T2i = Bi + Di;\n    const T3r = inv * (Br - Dr);\n    const T3i = inv * (Bi - Di);\n\n    // Final values\n    out[outOff] = T0r + T2r;\n    out[outOff + 1] = T0i + T2i;\n    out[outOff + 2] = T1r + T3i;\n    out[outOff + 3] = T1i - T3r;\n    out[outOff + 4] = T0r - T2r;\n    out[outOff + 5] = T0i - T2i;\n    out[outOff + 6] = T1r - T3i;\n    out[outOff + 7] = T1i + T3r;\n  }\n\n  /**\n   * Real input radix-4 implementation\n   * @param {Float32Array} out Output array for the transformed data\n   * @param {Float32Array} data Input array of real data to be transformed\n   * @param {number} inv The scale factor used to normalize the inverse transform\n   */\n  _realTransform4(out, data, inv) {\n    // Real input radix-4 implementation\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    var outOff;\n    var t;\n    var bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n        const off = bitrev[t];\n        this._singleRealTransform2(data, out, outOff, off >>> 1, step >>> 1);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n        const off = bitrev[t];\n        this._singleRealTransform4(data, out, outOff, off >>> 1, step >>> 1, inv);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      const halfLen = len >>> 1;\n      const quarterLen = halfLen >>> 1;\n      const hquarterLen = quarterLen >>> 1;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n          const A = outOff + i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n          const tableBr = this.table[k];\n          const tableBi = inv * this.table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = this.table[2 * k];\n          const tableCi = inv * this.table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = this.table[3 * k];\n          const tableDi = inv * this.table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = Ar + MCr;\n          const T0i = Ai + MCi;\n          const T1r = Ar - MCr;\n          const T1i = Ai - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          out[A] = T0r + T2r;\n          out[A + 1] = T0i + T2i;\n          out[B] = T1r + T3i;\n          out[B + 1] = T1i - T3r;\n\n          // Output final middle point\n          if (i === 0) {\n            out[C] = T0r - T2r;\n            out[C + 1] = T0i - T2i;\n            continue;\n          }\n\n          // Do not overwrite ourselves\n          if (i === hquarterLen) continue;\n          const SA = outOff + quarterLen - i;\n          const SB = outOff + halfLen - i;\n          out[SA] = T1r + -inv * T3i;\n          out[SA + 1] = -T1i - inv * T3r;\n          out[SB] = T0r + -inv * T2r;\n          out[SB + 1] = -T0i + inv * T2i;\n        }\n      }\n    }\n  }\n\n  /**\n   * Performs a single real input radix-2 transformation on the provided data\n   * \n   * @param {Float32Array} data The input data array\n   * @param {Float32Array} out The output data array\n   * @param {number} outOff The output offset\n   * @param {number} off The input offset\n   * @param {number} step The step\n   * \n   * @returns {void}\n   */\n  _singleRealTransform2(data, out, outOff, off, step) {\n    // radix-2 implementation\n    // NOTE: Only called for len=4\n\n    const evenR = data[off];\n    const oddR = data[off + step];\n    out[outOff] = evenR + oddR;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = evenR - oddR;\n    out[outOff + 3] = 0;\n  }\n\n  /**\n   * Computes a single real-valued transform using radix-4 algorithm.\n   * This method is only called for len=8.\n   *\n   * @param {Float32Array} data The input data array.\n   * @param {Float32Array} out The output data array.\n   * @param {number} outOff The offset into the output array.\n   * @param {number} off The offset into the input array.\n   * @param {number} step The step size for the input array.\n   * @param {number} inv The value of inverse.\n   */\n  _singleRealTransform4(data, out, outOff, off, step, inv) {\n    // radix-4\n    // NOTE: Only called for len=8\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Br = data[off + step];\n    const Cr = data[off + step2];\n    const Dr = data[off + step3];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T1r = Ar - Cr;\n    const T2r = Br + Dr;\n    const T3r = inv * (Br - Dr);\n\n    // Final values\n    out[outOff] = T0r + T2r;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = T1r;\n    out[outOff + 3] = -T3r;\n    out[outOff + 4] = T0r - T2r;\n    out[outOff + 5] = 0;\n    out[outOff + 6] = T1r;\n    out[outOff + 7] = T3r;\n  }\n}","map":{"version":3,"names":["interpolate_data","input","_ref","_ref2","in_channels","in_height","in_width","out_height","out_width","mode","arguments","length","undefined","align_corners","x_scale","y_scale","out_img","constructor","inStride","outStride","i","j","outOffset","x","y","x1","Math","floor","y1","x2","min","y2","max","s","t","w1","w2","w3","w4","yStride","xStride","idx1","idx2","idx3","idx4","k","cOffset","transpose_data","array","dims","axes","shape","Array","stride","invStride","map","_","indexOf","transposedData","newIndex","softmax","arr","maxVal","exps","exp","sumExps","reduce","acc","val","softmaxArr","log_softmax","logSoftmaxArr","log","dot","arr1","arr2","getTopItems","items","top_k","from","sort","a","b","slice","cos_sim","dotProduct","magnitudeA","magnitude","magnitudeB","cosineSimilarity","sqrt","Error","indexOfMin","indexOfMax","rfftfreq","n","d","Number","isInteger","TypeError","len","results","FFT","size","_csize","table","Float32Array","angle","PI","cos","sin","power","_width","_bitrev","Int32Array","shift","revShift","createComplexArray","fromComplexArray","complex","storage","res","toComplexArray","completeSpectrum","spectrum","half","transform","out","data","_transform4","realTransform","_realTransform4","inverseTransform","inv","width","step","outOff","bitrev","off","_singleTransform2","_singleTransform4","quarterLen","limit","A","B","C","D","Ar","Ai","Br","Bi","Cr","Ci","Dr","Di","tableBr","tableBi","MBr","MBi","tableCr","tableCi","MCr","MCi","tableDr","tableDi","MDr","MDi","T0r","T0i","T1r","T1i","T2r","T2i","T3r","T3i","evenR","evenI","oddR","oddI","step2","step3","_singleRealTransform2","_singleRealTransform4","halfLen","hquarterLen","SA","SB"],"sources":["/Users/phreetech13/Desktop/RealTimeAudioToText/node_modules/@xenova/transformers/src/utils/maths.js"],"sourcesContent":["\n/**\n * @file Helper module for mathematical processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/maths\n */\n\n/**\n * @typedef {Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array} TypedArray\n * @typedef {BigInt64Array | BigUint64Array} BigTypedArray\n * @typedef {TypedArray | BigTypedArray} AnyTypedArray\n */\n\n/**\n * @param {TypedArray} input\n */\nexport function interpolate_data(input, [in_channels, in_height, in_width], [out_height, out_width], mode = 'bilinear', align_corners = false) {\n    // TODO use mode and align_corners\n\n    // Output image dimensions\n    const x_scale = out_width / in_width;\n    const y_scale = out_height / in_height;\n\n    // Output image\n    // @ts-ignore\n    const out_img = new input.constructor(out_height * out_width * in_channels);\n\n    // Pre-calculate strides\n    const inStride = in_height * in_width;\n    const outStride = out_height * out_width;\n\n    for (let i = 0; i < out_height; ++i) {\n        for (let j = 0; j < out_width; ++j) {\n            // Calculate output offset\n            const outOffset = i * out_width + j;\n\n            // Calculate input pixel coordinates\n            const x = (j + 0.5) / x_scale - 0.5;\n            const y = (i + 0.5) / y_scale - 0.5;\n\n            // Calculate the four nearest input pixels\n            // We also check if the input pixel coordinates are within the image bounds\n            let x1 = Math.floor(x);\n            let y1 = Math.floor(y);\n            const x2 = Math.min(x1 + 1, in_width - 1);\n            const y2 = Math.min(y1 + 1, in_height - 1);\n\n            x1 = Math.max(x1, 0);\n            y1 = Math.max(y1, 0);\n\n\n            // Calculate the fractional distances between the input pixel and the four nearest pixels\n            const s = x - x1;\n            const t = y - y1;\n\n            // Perform bilinear interpolation\n            const w1 = (1 - s) * (1 - t);\n            const w2 = s * (1 - t);\n            const w3 = (1 - s) * t;\n            const w4 = s * t;\n\n            // Calculate the four nearest input pixel indices\n            const yStride = y1 * in_width;\n            const xStride = y2 * in_width;\n            const idx1 = yStride + x1;\n            const idx2 = yStride + x2;\n            const idx3 = xStride + x1;\n            const idx4 = xStride + x2;\n\n            for (let k = 0; k < in_channels; ++k) {\n                // Calculate channel offset\n                const cOffset = k * inStride;\n\n                out_img[k * outStride + outOffset] =\n                    w1 * input[cOffset + idx1] +\n                    w2 * input[cOffset + idx2] +\n                    w3 * input[cOffset + idx3] +\n                    w4 * input[cOffset + idx4];\n            }\n        }\n    }\n\n    return out_img;\n}\n\n\n/**\n * Helper method to transpose a `AnyTypedArray` directly\n * @param {T} array \n * @template {AnyTypedArray} T \n * @param {number[]} dims \n * @param {number[]} axes \n * @returns {[T, number[]]} The transposed array and the new shape.\n */\nexport function transpose_data(array, dims, axes) {\n    // Calculate the new shape of the transposed array\n    // and the stride of the original array\n    const shape = new Array(axes.length);\n    const stride = new Array(axes.length);\n\n    for (let i = axes.length - 1, s = 1; i >= 0; --i) {\n        stride[i] = s;\n        shape[i] = dims[axes[i]];\n        s *= shape[i];\n    }\n\n    // Precompute inverse mapping of stride\n    const invStride = axes.map((_, i) => stride[axes.indexOf(i)]);\n\n    // Create the transposed array with the new shape\n    // @ts-ignore\n    const transposedData = new array.constructor(array.length);\n\n    // Transpose the original array to the new array\n    for (let i = 0; i < array.length; ++i) {\n        let newIndex = 0;\n        for (let j = dims.length - 1, k = i; j >= 0; --j) {\n            newIndex += (k % dims[j]) * invStride[j];\n            k = Math.floor(k / dims[j]);\n        }\n        transposedData[newIndex] = array[i];\n    }\n\n    return [transposedData, shape];\n}\n\n\n/**\n * Compute the softmax of an array of numbers.\n *\n * @param {number[]} arr The array of numbers to compute the softmax of.\n * @returns {number[]} The softmax array.\n */\nexport function softmax(arr) {\n    // Compute the maximum value in the array\n    const maxVal = max(arr)[0];\n\n    // Compute the exponentials of the array values\n    const exps = arr.map(x => Math.exp(x - maxVal));\n\n    // Compute the sum of the exponentials\n    const sumExps = exps.reduce((acc, val) => acc + val, 0);\n\n    // Compute the softmax values\n    const softmaxArr = exps.map(x => x / sumExps);\n\n    return softmaxArr;\n}\n\n/**\n * Calculates the logarithm of the softmax function for the input array.\n * @param {number[]} arr The input array to calculate the log_softmax function for.\n * @returns {any} The resulting log_softmax array.\n */\nexport function log_softmax(arr) {\n    // Compute the softmax values\n    const softmaxArr = softmax(arr);\n\n    // Apply log formula to each element\n    const logSoftmaxArr = softmaxArr.map(x => Math.log(x));\n\n    return logSoftmaxArr;\n}\n\n/**\n * Calculates the dot product of two arrays.\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The dot product of arr1 and arr2.\n */\nexport function dot(arr1, arr2) {\n    return arr1.reduce((acc, val, i) => acc + val * arr2[i], 0);\n}\n\n\n/**\n * Get the top k items from an iterable, sorted by descending order\n *\n * @param {Array} items The items to be sorted\n * @param {number} [top_k=0] The number of top items to return (default: 0 = return all)\n * @returns {Array} The top k items, sorted by descending order\n */\nexport function getTopItems(items, top_k = 0) {\n    // if top == 0, return all\n\n    items = Array.from(items)\n        .map((x, i) => [i, x])            // Get indices ([index, score])\n        .sort((a, b) => b[1] - a[1])      // Sort by log probabilities\n\n    if (top_k > 0) {\n        items = items.slice(0, top_k);    // Get top k items\n    }\n\n    return items\n}\n\n/**\n * Computes the cosine similarity between two arrays.\n *\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The cosine similarity between the two arrays.\n */\nexport function cos_sim(arr1, arr2) {\n    // Calculate dot product of the two arrays\n    const dotProduct = dot(arr1, arr2);\n\n    // Calculate the magnitude of the first array\n    const magnitudeA = magnitude(arr1);\n\n    // Calculate the magnitude of the second array\n    const magnitudeB = magnitude(arr2);\n\n    // Calculate the cosine similarity\n    const cosineSimilarity = dotProduct / (magnitudeA * magnitudeB);\n\n    return cosineSimilarity;\n}\n\n/**\n * Calculates the magnitude of a given array.\n * @param {number[]} arr The array to calculate the magnitude of.\n * @returns {number} The magnitude of the array.\n */\nexport function magnitude(arr) {\n    return Math.sqrt(arr.reduce((acc, val) => acc + val * val, 0));\n}\n\n\n/**\n * Returns the value and index of the minimum element in an array.\n * @param {number[]} arr array of numbers.\n * @returns {number[]} the value and index of the minimum element, of the form: [valueOfMin, indexOfMin]\n * @throws {Error} If array is empty.\n */\nexport function min(arr) {\n    if (arr.length === 0) throw Error('Array must not be empty');\n    let min = arr[0];\n    let indexOfMin = 0;\n    for (let i = 1; i < arr.length; ++i) {\n        if (arr[i] < min) {\n            min = arr[i];\n            indexOfMin = i;\n        }\n    }\n    return [min, indexOfMin];\n}\n\n\n/**\n * Returns the value and index of the maximum element in an array.\n * @param {number[]} arr array of numbers.\n * @returns {number[]} the value and index of the maximum element, of the form: [valueOfMax, indexOfMax]\n * @throws {Error} If array is empty.\n */\nexport function max(arr) {\n    if (arr.length === 0) throw Error('Array must not be empty');\n    let max = arr[0];\n    let indexOfMax = 0;\n    for (let i = 1; i < arr.length; ++i) {\n        if (arr[i] > max) {\n            max = arr[i];\n            indexOfMax = i;\n        }\n    }\n    return [max, indexOfMax];\n}\n\n/**\n * Return the Discrete Fourier Transform sample frequencies.\n * \n * Code adapted from https://github.com/numpy/numpy/blob/25908cacd19915bf3ddd659c28be28a41bd97a54/numpy/fft/helper.py#L173-L221\n * Original Python doc: https://numpy.org/doc/stable/reference/generated/numpy.fft.rfftfreq.html\n * @example\n * rfftfreq(400, 1 / 16000) // (201)Â [0, 40, 80, 120, 160, 200, ..., 8000]\n * @param {number} n Window length\n * @param {number} [d = 1.0] Sample spacing (inverse of the sampling rate). Defaults to 1.\n * @throws {TypeError} If n is not an integer.\n * @returns {number[]} Array of length `Math.floor(n / 2) + 1;` containing the sample frequencies.\n */\nexport function rfftfreq(n, d = 1.0) {\n    if (!Number.isInteger(n)) {\n        throw new TypeError(`n should be an integer, but ${n} given.`);\n    }\n    const val = 1.0 / (n * d);\n    const len = Math.floor(n / 2) + 1;\n    const results = new Array(len);\n    for (let i = 0; i < len; ++i) {\n        results[i] = i * val;\n    }\n    return results;\n}\n\n/**\n * FFT class provides functionality for performing Fast Fourier Transform on arrays\n * Code adapted from https://www.npmjs.com/package/fft.js\n */\nexport class FFT {\n    /**\n     * @param {number} size The size of the input array. Must be a power of two and bigger than 1.\n     * @throws {Error} FFT size must be a power of two and bigger than 1.\n     */\n    constructor(size) {\n        this.size = size | 0; // convert to a 32-bit signed integer\n        if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n            throw new Error('FFT size must be a power of two and bigger than 1');\n\n        this._csize = size << 1;\n\n        this.table = new Float32Array(this.size * 2);\n        for (let i = 0; i < this.table.length; i += 2) {\n            const angle = Math.PI * i / this.size;\n            this.table[i] = Math.cos(angle);\n            this.table[i + 1] = -Math.sin(angle);\n        }\n\n        // Find size's power of two\n        let power = 0;\n        for (let t = 1; this.size > t; t <<= 1)\n            ++power;\n\n        // Calculate initial step's width:\n        //   * If we are full radix-4, it is 2x smaller to give inital len=8\n        //   * Otherwise it is the same as `power` to give len=4\n        this._width = power % 2 === 0 ? power - 1 : power;\n\n        // Pre-compute bit-reversal patterns\n        this._bitrev = new Int32Array(1 << this._width);\n        for (let j = 0; j < this._bitrev.length; ++j) {\n            this._bitrev[j] = 0;\n            for (let shift = 0; shift < this._width; shift += 2) {\n                const revShift = this._width - shift - 2;\n                this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n            }\n        }\n    }\n\n    /**\n     * Create a complex number array with size `2 * size`\n     *\n     * @returns {Float32Array} A complex number array with size `2 * size`\n     */\n    createComplexArray() {\n        return new Float32Array(this._csize);\n    }\n\n    /**\n     * Converts a complex number representation stored in a Float32Array to an array of real numbers.\n     * \n     * @param {Float32Array} complex The complex number representation to be converted.\n     * @param {number[]} [storage] An optional array to store the result in.\n     * @returns {number[]} An array of real numbers representing the input complex number representation.\n     */\n    fromComplexArray(complex, storage) {\n        const res = storage || new Array(complex.length >>> 1);\n        for (let i = 0; i < complex.length; i += 2)\n            res[i >>> 1] = complex[i];\n        return res;\n    }\n\n    /**\n     * Convert a real-valued input array to a complex-valued output array.\n     * @param {Float32Array} input The real-valued input array.\n     * @param {Float32Array} [storage] Optional buffer to store the output array.\n     * @returns {Float32Array} The complex-valued output array.\n     */\n    toComplexArray(input, storage) {\n        const res = storage || this.createComplexArray();\n        for (let i = 0; i < res.length; i += 2) {\n            res[i] = input[i >>> 1];\n            res[i + 1] = 0;\n        }\n        return res;\n    }\n\n    /**\n     * Completes the spectrum by adding its mirrored negative frequency components.\n     * @param {Float32Array} spectrum The input spectrum.\n     * @returns {void}\n     */\n    completeSpectrum(spectrum) {\n        const size = this._csize;\n        const half = size >>> 1;\n        for (let i = 2; i < half; i += 2) {\n            spectrum[size - i] = spectrum[i];\n            spectrum[size - i + 1] = -spectrum[i + 1];\n        }\n    }\n\n    /**\n     * Performs a Fast Fourier Transform (FFT) on the given input data and stores the result in the output buffer.\n     * \n     * @param {Float32Array} out The output buffer to store the result.\n     * @param {Float32Array} data The input data to transform.\n     * \n     * @throws {Error} Input and output buffers must be different.\n     * \n     * @returns {void}\n     */\n    transform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._transform4(out, data, 1 /* DONE */);\n    }\n\n    /**\n     * Performs a real-valued forward FFT on the given input buffer and stores the result in the given output buffer.\n     * The input buffer must contain real values only, while the output buffer will contain complex values. The input and\n     * output buffers must be different.\n     *\n     * @param {Float32Array} out The output buffer.\n     * @param {Float32Array} data The input buffer containing real values.\n     *\n     * @throws {Error} If the input and output buffers are the same.\n     */\n    realTransform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._realTransform4(out, data, 1 /* DONE */);\n    }\n\n    /**\n     * Performs an inverse FFT transformation on the given `data` array, and stores the result in `out`.\n     * The `out` array must be a different buffer than the `data` array. The `out` array will contain the\n     * result of the transformation. The `data` array will not be modified.\n     * \n     * @param {Float32Array} out The output buffer for the transformed data.\n     * @param {Float32Array} data The input data to transform.\n     * @throws {Error} If `out` and `data` refer to the same buffer.\n     * @returns {void}\n     */\n    inverseTransform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._transform4(out, data, -1 /* DONE */);\n        for (let i = 0; i < out.length; ++i)\n            out[i] /= this.size;\n    }\n\n    /**\n     * Performs a radix-4 implementation of a discrete Fourier transform on a given set of data.\n     *\n     * @param {Float32Array} out The output buffer for the transformed data.\n     * @param {Float32Array} data The input buffer of data to be transformed.\n     * @param {number} inv A scaling factor to apply to the transform.\n     * @returns {void}\n     */\n    _transform4(out, data, inv) {\n        // radix-4 implementation\n\n        const size = this._csize;\n\n        // Initial step (permute and transform)\n        const width = this._width;\n        let step = 1 << width;\n        let len = (size / step) << 1;\n\n        let outOff;\n        let t;\n        let bitrev = this._bitrev;\n        if (len === 4) {\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleTransform2(data, out, outOff, off, step);\n            }\n        } else {\n            // len === 8\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleTransform4(data, out, outOff, off, step, inv);\n            }\n        }\n\n        // Loop through steps in decreasing order\n        for (step >>= 2; step >= 2; step >>= 2) {\n            len = (size / step) << 1;\n            let quarterLen = len >>> 2;\n\n            // Loop through offsets in the data\n            for (outOff = 0; outOff < size; outOff += len) {\n                // Full case\n                let limit = outOff + quarterLen;\n                for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n                    const A = i;\n                    const B = A + quarterLen;\n                    const C = B + quarterLen;\n                    const D = C + quarterLen;\n\n                    // Original values\n                    const Ar = out[A];\n                    const Ai = out[A + 1];\n                    const Br = out[B];\n                    const Bi = out[B + 1];\n                    const Cr = out[C];\n                    const Ci = out[C + 1];\n                    const Dr = out[D];\n                    const Di = out[D + 1];\n\n                    const tableBr = this.table[k];\n                    const tableBi = inv * this.table[k + 1];\n                    const MBr = Br * tableBr - Bi * tableBi;\n                    const MBi = Br * tableBi + Bi * tableBr;\n\n                    const tableCr = this.table[2 * k];\n                    const tableCi = inv * this.table[2 * k + 1];\n                    const MCr = Cr * tableCr - Ci * tableCi;\n                    const MCi = Cr * tableCi + Ci * tableCr;\n\n                    const tableDr = this.table[3 * k];\n                    const tableDi = inv * this.table[3 * k + 1];\n                    const MDr = Dr * tableDr - Di * tableDi;\n                    const MDi = Dr * tableDi + Di * tableDr;\n\n                    // Pre-Final values\n                    const T0r = Ar + MCr;\n                    const T0i = Ai + MCi;\n                    const T1r = Ar - MCr;\n                    const T1i = Ai - MCi;\n                    const T2r = MBr + MDr;\n                    const T2i = MBi + MDi;\n                    const T3r = inv * (MBr - MDr);\n                    const T3i = inv * (MBi - MDi);\n\n                    // Final values\n                    out[A] = T0r + T2r;\n                    out[A + 1] = T0i + T2i;\n                    out[B] = T1r + T3i;\n                    out[B + 1] = T1i - T3r;\n                    out[C] = T0r - T2r;\n                    out[C + 1] = T0i - T2i;\n                    out[D] = T1r - T3i;\n                    out[D + 1] = T1i + T3r;\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a radix-2 implementation of a discrete Fourier transform on a given set of data.\n     *\n     * @param {Float32Array} data The input buffer of data to be transformed.\n     * @param {Float32Array} out The output buffer for the transformed data.\n     * @param {number} outOff The offset at which to write the output data.\n     * @param {number} off The offset at which to begin reading the input data.\n     * @param {number} step The step size for indexing the input data.\n     * @returns {void}\n     */\n    _singleTransform2(data, out, outOff, off, step) {\n        // radix-2 implementation\n        // NOTE: Only called for len=4\n\n        const evenR = data[off];\n        const evenI = data[off + 1];\n        const oddR = data[off + step];\n        const oddI = data[off + step + 1];\n\n        out[outOff] = evenR + oddR;\n        out[outOff + 1] = evenI + oddI;\n        out[outOff + 2] = evenR - oddR;\n        out[outOff + 3] = evenI - oddI;\n    }\n\n    /**\n     * Performs radix-4 transformation on input data of length 8\n     *\n     * @param {Float32Array} data Input data array of length 8\n     * @param {Float32Array} out Output data array of length 8\n     * @param {number} outOff Index of output array to start writing from\n     * @param {number} off Index of input array to start reading from\n     * @param {number} step Step size between elements in input array\n     * @param {number} inv Scaling factor for inverse transform\n     * \n     * @returns {void}\n     */\n    _singleTransform4(data, out, outOff, off, step, inv) {\n        // radix-4\n        // NOTE: Only called for len=8\n        const step2 = step * 2;\n        const step3 = step * 3;\n\n        // Original values\n        const Ar = data[off];\n        const Ai = data[off + 1];\n        const Br = data[off + step];\n        const Bi = data[off + step + 1];\n        const Cr = data[off + step2];\n        const Ci = data[off + step2 + 1];\n        const Dr = data[off + step3];\n        const Di = data[off + step3 + 1];\n\n        // Pre-Final values\n        const T0r = Ar + Cr;\n        const T0i = Ai + Ci;\n        const T1r = Ar - Cr;\n        const T1i = Ai - Ci;\n        const T2r = Br + Dr;\n        const T2i = Bi + Di;\n        const T3r = inv * (Br - Dr);\n        const T3i = inv * (Bi - Di);\n\n        // Final values\n        out[outOff] = T0r + T2r;\n        out[outOff + 1] = T0i + T2i;\n        out[outOff + 2] = T1r + T3i;\n        out[outOff + 3] = T1i - T3r;\n        out[outOff + 4] = T0r - T2r;\n        out[outOff + 5] = T0i - T2i;\n        out[outOff + 6] = T1r - T3i;\n        out[outOff + 7] = T1i + T3r;\n    }\n\n    /**\n     * Real input radix-4 implementation\n     * @param {Float32Array} out Output array for the transformed data\n     * @param {Float32Array} data Input array of real data to be transformed\n     * @param {number} inv The scale factor used to normalize the inverse transform\n     */\n    _realTransform4(out, data, inv) {\n        // Real input radix-4 implementation\n        const size = this._csize;\n\n        // Initial step (permute and transform)\n        const width = this._width;\n        let step = 1 << width;\n        let len = (size / step) << 1;\n\n        var outOff;\n        var t;\n        var bitrev = this._bitrev;\n        if (len === 4) {\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleRealTransform2(data, out, outOff, off >>> 1, step >>> 1);\n            }\n        } else {\n            // len === 8\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleRealTransform4(data, out, outOff, off >>> 1, step >>> 1, inv);\n            }\n        }\n\n        // Loop through steps in decreasing order\n        for (step >>= 2; step >= 2; step >>= 2) {\n            len = (size / step) << 1;\n            const halfLen = len >>> 1;\n            const quarterLen = halfLen >>> 1;\n            const hquarterLen = quarterLen >>> 1;\n\n            // Loop through offsets in the data\n            for (outOff = 0; outOff < size; outOff += len) {\n                for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n                    const A = outOff + i;\n                    const B = A + quarterLen;\n                    const C = B + quarterLen;\n                    const D = C + quarterLen;\n\n                    // Original values\n                    const Ar = out[A];\n                    const Ai = out[A + 1];\n                    const Br = out[B];\n                    const Bi = out[B + 1];\n                    const Cr = out[C];\n                    const Ci = out[C + 1];\n                    const Dr = out[D];\n                    const Di = out[D + 1];\n\n                    const tableBr = this.table[k];\n                    const tableBi = inv * this.table[k + 1];\n                    const MBr = Br * tableBr - Bi * tableBi;\n                    const MBi = Br * tableBi + Bi * tableBr;\n\n                    const tableCr = this.table[2 * k];\n                    const tableCi = inv * this.table[2 * k + 1];\n                    const MCr = Cr * tableCr - Ci * tableCi;\n                    const MCi = Cr * tableCi + Ci * tableCr;\n\n                    const tableDr = this.table[3 * k];\n                    const tableDi = inv * this.table[3 * k + 1];\n                    const MDr = Dr * tableDr - Di * tableDi;\n                    const MDi = Dr * tableDi + Di * tableDr;\n\n                    // Pre-Final values\n                    const T0r = Ar + MCr;\n                    const T0i = Ai + MCi;\n                    const T1r = Ar - MCr;\n                    const T1i = Ai - MCi;\n                    const T2r = MBr + MDr;\n                    const T2i = MBi + MDi;\n                    const T3r = inv * (MBr - MDr);\n                    const T3i = inv * (MBi - MDi);\n\n                    // Final values\n                    out[A] = T0r + T2r;\n                    out[A + 1] = T0i + T2i;\n                    out[B] = T1r + T3i;\n                    out[B + 1] = T1i - T3r;\n\n                    // Output final middle point\n                    if (i === 0) {\n                        out[C] = T0r - T2r;\n                        out[C + 1] = T0i - T2i;\n                        continue;\n                    }\n\n                    // Do not overwrite ourselves\n                    if (i === hquarterLen)\n                        continue;\n\n                    const SA = outOff + quarterLen - i;\n                    const SB = outOff + halfLen - i;\n\n                    out[SA] = T1r + -inv * T3i;\n                    out[SA + 1] = -T1i - inv * T3r;\n                    out[SB] = T0r + -inv * T2r;\n                    out[SB + 1] = -T0i + inv * T2i;\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a single real input radix-2 transformation on the provided data\n     * \n     * @param {Float32Array} data The input data array\n     * @param {Float32Array} out The output data array\n     * @param {number} outOff The output offset\n     * @param {number} off The input offset\n     * @param {number} step The step\n     * \n     * @returns {void}\n     */\n    _singleRealTransform2(data, out, outOff, off, step) {\n        // radix-2 implementation\n        // NOTE: Only called for len=4\n\n        const evenR = data[off];\n        const oddR = data[off + step];\n\n        out[outOff] = evenR + oddR;\n        out[outOff + 1] = 0;\n        out[outOff + 2] = evenR - oddR;\n        out[outOff + 3] = 0;\n    }\n\n    /**\n     * Computes a single real-valued transform using radix-4 algorithm.\n     * This method is only called for len=8.\n     *\n     * @param {Float32Array} data The input data array.\n     * @param {Float32Array} out The output data array.\n     * @param {number} outOff The offset into the output array.\n     * @param {number} off The offset into the input array.\n     * @param {number} step The step size for the input array.\n     * @param {number} inv The value of inverse.\n     */\n    _singleRealTransform4(data, out, outOff, off, step, inv) {\n        // radix-4\n        // NOTE: Only called for len=8\n        const step2 = step * 2;\n        const step3 = step * 3;\n\n        // Original values\n        const Ar = data[off];\n        const Br = data[off + step];\n        const Cr = data[off + step2];\n        const Dr = data[off + step3];\n\n        // Pre-Final values\n        const T0r = Ar + Cr;\n        const T1r = Ar - Cr;\n        const T2r = Br + Dr;\n        const T3r = inv * (Br - Dr);\n\n        // Final values\n        out[outOff] = T0r + T2r;\n        out[outOff + 1] = 0;\n        out[outOff + 2] = T1r;\n        out[outOff + 3] = -T3r;\n        out[outOff + 4] = T0r - T2r;\n        out[outOff + 5] = 0;\n        out[outOff + 6] = T1r;\n        out[outOff + 7] = T3r;\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}