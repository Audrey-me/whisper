{"ast":null,"code":"/**\n * @file Helper module for image processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/image\n */\n\nimport fs from 'fs';\nimport { isString } from './core.js';\nimport { getFile } from './hub.js';\nimport { env } from '../env.js';\n\n// Will be empty (or not used) if running in browser or web-worker\nimport sharp from 'sharp';\nconst BROWSER_ENV = typeof self !== 'undefined';\nlet createCanvasFunction;\nlet ImageDataClass;\nlet loadImageFunction;\nif (BROWSER_ENV) {\n  // Running in browser or web-worker\n  createCanvasFunction = ( /** @type {number} */width, /** @type {number} */height) => {\n    if (!self.OffscreenCanvas) {\n      throw new Error('OffscreenCanvas not supported by this browser.');\n    }\n    return new self.OffscreenCanvas(width, height);\n  };\n  loadImageFunction = self.createImageBitmap;\n  ImageDataClass = self.ImageData;\n} else if (sharp) {\n  // Running in Node.js, electron, or other non-browser environment\n\n  loadImageFunction = async ( /**@type {sharp.Sharp}*/img) => {\n    let {\n      data,\n      info\n    } = await img.raw().toBuffer({\n      resolveWithObject: true\n    });\n    return new RawImage(new Uint8ClampedArray(data), info.width, info.height, info.channels);\n  };\n} else {\n  throw new Error('Unable to load image processing library.');\n}\n\n// Defined here: https://github.com/python-pillow/Pillow/blob/a405e8406b83f8bfb8916e93971edc7407b8b1ff/src/libImaging/Imaging.h#L262-L268\nconst RESAMPLING_MAPPING = {\n  0: 'nearest',\n  1: 'lanczos',\n  2: 'bilinear',\n  3: 'bicubic',\n  4: 'box',\n  5: 'hamming'\n};\nexport class RawImage {\n  /**\n   * Create a new `RawImage` object.\n   * @param {Uint8ClampedArray} data The pixel data.\n   * @param {number} width The width of the image.\n   * @param {number} height The height of the image.\n   * @param {1|2|3|4} channels The number of channels.\n   */\n  constructor(data, width, height, channels) {\n    this._update(data, width, height, channels);\n  }\n\n  /**\n   * Helper method for reading an image from a variety of input types.\n   * @param {RawImage|string|URL} input \n   * @returns The image object.\n   * \n   * **Example:** Read image from a URL.\n   * ```javascript\n   * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');\n   * // test {\n   * //   \"data\": Uint8ClampedArray [ 25, 25, 25, 19, 19, 19, ... ],\n   * //   \"width\": 800,\n   * //   \"height\": 533,\n   * //   \"channels\": 3\n   * // }\n   * ```\n   */\n  static async read(input) {\n    if (input instanceof RawImage) {\n      return input;\n    } else if (isString(input) || input instanceof URL) {\n      return await this.fromURL(input);\n    } else {\n      throw new Error(`Unsupported input type: ${typeof input}`);\n    }\n  }\n\n  /**\n   * Read an image from a URL or file path.\n   * @param {string|URL} url The URL or file path to read the image from.\n   * @returns {Promise<RawImage>} The image object.\n   */\n  static async fromURL(url) {\n    let response = await getFile(url);\n    let blob = await response.blob();\n    return this.fromBlob(blob);\n  }\n\n  /**\n   * Helper method to create a new Image from a blob.\n   * @param {Blob} blob The blob to read the image from.\n   * @returns {Promise<RawImage>} The image object.\n   */\n  static async fromBlob(blob) {\n    if (BROWSER_ENV) {\n      // Running in environment with canvas\n      let img = await loadImageFunction(blob);\n      const ctx = createCanvasFunction(img.width, img.height).getContext('2d');\n\n      // Draw image to context\n      ctx.drawImage(img, 0, 0);\n      return new this(ctx.getImageData(0, 0, img.width, img.height).data, img.width, img.height, 4);\n    } else {\n      // Use sharp.js to read (and possible resize) the image.\n      let img = sharp(await blob.arrayBuffer());\n      return await loadImageFunction(img);\n    }\n  }\n\n  /**\n   * Convert the image to grayscale format.\n   * @returns {RawImage} `this` to support chaining.\n   */\n  grayscale() {\n    if (this.channels === 1) {\n      return this;\n    }\n    let newData = new Uint8ClampedArray(this.width * this.height * 3);\n    switch (this.channels) {\n      case 3: // rgb to grayscale\n      case 4:\n        // rgba to grayscale\n        for (let i = 0, offset = 0; i < this.data.length; i += this.channels) {\n          const red = this.data[i];\n          const green = this.data[i + 1];\n          const blue = this.data[i + 2];\n          newData[offset++] = Math.round(0.2989 * red + 0.5870 * green + 0.1140 * blue);\n        }\n        break;\n      default:\n        throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n    }\n    return this._update(newData, this.width, this.height, 1);\n  }\n\n  /**\n   * Convert the image to RGB format.\n   * @returns {RawImage} `this` to support chaining.\n   */\n  rgb() {\n    if (this.channels === 3) {\n      return this;\n    }\n    let newData = new Uint8ClampedArray(this.width * this.height * 3);\n    switch (this.channels) {\n      case 1:\n        // grayscale to rgb\n        for (let i = 0, offset = 0; i < this.data.length; ++i) {\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i];\n        }\n        break;\n      case 4:\n        // rgba to rgb\n        for (let i = 0, offset = 0; i < this.data.length; i += 4) {\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i + 1];\n          newData[offset++] = this.data[i + 2];\n        }\n        break;\n      default:\n        throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n    }\n    return this._update(newData, this.width, this.height, 3);\n  }\n\n  /**\n   * Convert the image to RGBA format.\n   * @returns {RawImage} `this` to support chaining.\n   */\n  rgba() {\n    if (this.channels === 4) {\n      return this;\n    }\n    let newData = new Uint8ClampedArray(this.width * this.height * 4);\n    switch (this.channels) {\n      case 1:\n        // grayscale to rgba\n        for (let i = 0, offset = 0; i < this.data.length; ++i) {\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i];\n          newData[offset++] = 255;\n        }\n        break;\n      case 3:\n        // rgb to rgba\n        for (let i = 0, offset = 0; i < this.data.length; i += 3) {\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i + 1];\n          newData[offset++] = this.data[i + 2];\n          newData[offset++] = 255;\n        }\n        break;\n      default:\n        throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n    }\n    return this._update(newData, this.width, this.height, 4);\n  }\n\n  /**\n   * Resize the image to the given dimensions. This method uses the canvas API to perform the resizing.\n   * @param {number} width The width of the new image.\n   * @param {number} height The height of the new image.\n   * @param {Object} options Additional options for resizing.\n   * @param {0|1|2|3|4|5|string} [options.resample] The resampling method to use.\n   * @returns {Promise<RawImage>} `this` to support chaining.\n   */\n  async resize(width, height) {\n    let {\n      resample = 2\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // Ensure resample method is a string\n    let resampleMethod = RESAMPLING_MAPPING[resample] ?? resample;\n    if (BROWSER_ENV) {\n      // TODO use `resample` in browser environment\n\n      // Store number of channels before resizing\n      let numChannels = this.channels;\n\n      // Create canvas object for this image\n      let canvas = this.toCanvas();\n\n      // Actually perform resizing using the canvas API\n      const ctx = createCanvasFunction(width, height).getContext('2d');\n\n      // Draw image to context, resizing in the process\n      ctx.drawImage(canvas, 0, 0, width, height);\n\n      // Create image from the resized data\n      let resizedImage = new RawImage(ctx.getImageData(0, 0, width, height).data, width, height, 4);\n\n      // Convert back so that image has the same number of channels as before\n      return resizedImage.convert(numChannels);\n    } else {\n      // Create sharp image from raw data, and resize\n      let img = sharp(this.data, {\n        raw: {\n          width: this.width,\n          height: this.height,\n          channels: this.channels\n        }\n      });\n      switch (resampleMethod) {\n        case 'box':\n        case 'hamming':\n          if (resampleMethod === 'box' || resampleMethod === 'hamming') {\n            console.warn(`Resampling method ${resampleMethod} is not yet supported. Using bilinear instead.`);\n            resampleMethod = 'bilinear';\n          }\n        case 'nearest':\n        case 'bilinear':\n        case 'bicubic':\n          // Perform resizing using affine transform. \n          // This matches how the python Pillow library does it.\n          img = img.affine([width / this.width, 0, 0, height / this.height], {\n            interpolator: resampleMethod\n          });\n          break;\n        case 'lanczos':\n          // https://github.com/python-pillow/Pillow/discussions/5519\n          // https://github.com/lovell/sharp/blob/main/docs/api-resize.md\n          img = img.resize({\n            width,\n            height,\n            fit: 'fill',\n            kernel: 'lanczos3' // PIL Lanczos uses a kernel size of 3 \n          });\n\n          break;\n        default:\n          throw new Error(`Resampling method ${resampleMethod} is not supported.`);\n      }\n      return await loadImageFunction(img);\n    }\n  }\n  async pad(_ref) {\n    let [left, right, top, bottom] = _ref;\n    left = Math.max(left, 0);\n    right = Math.max(right, 0);\n    top = Math.max(top, 0);\n    bottom = Math.max(bottom, 0);\n    if (left === 0 && right === 0 && top === 0 && bottom === 0) {\n      // No padding needed\n      return this;\n    }\n    if (BROWSER_ENV) {\n      // Store number of channels before padding\n      let numChannels = this.channels;\n\n      // Create canvas object for this image\n      let canvas = this.toCanvas();\n      let newWidth = this.width + left + right;\n      let newHeight = this.height + top + bottom;\n\n      // Create a new canvas of the desired size.\n      const ctx = createCanvasFunction(newWidth, newHeight).getContext('2d');\n\n      // Draw image to context, padding in the process\n      ctx.drawImage(canvas, 0, 0, this.width, this.height, left, top, newWidth, newHeight);\n\n      // Create image from the padded data\n      let paddedImage = new RawImage(ctx.getImageData(0, 0, newWidth, newHeight).data, newWidth, newHeight, 4);\n\n      // Convert back so that image has the same number of channels as before\n      return paddedImage.convert(numChannels);\n    } else {\n      let img = sharp(this.data, {\n        raw: {\n          width: this.width,\n          height: this.height,\n          channels: this.channels\n        }\n      }).extend({\n        left,\n        right,\n        top,\n        bottom\n      });\n      return await loadImageFunction(img);\n    }\n  }\n  async center_crop(crop_width, crop_height) {\n    // If the image is already the desired size, return it\n    if (this.width === crop_width && this.height === crop_height) {\n      return this;\n    }\n\n    // Determine bounds of the image in the new canvas\n    let width_offset = (this.width - crop_width) / 2;\n    let height_offset = (this.height - crop_height) / 2;\n    if (BROWSER_ENV) {\n      // Store number of channels before resizing\n      let numChannels = this.channels;\n\n      // Create canvas object for this image\n      let canvas = this.toCanvas();\n\n      // Create a new canvas of the desired size. This is needed since if the \n      // image is too small, we need to pad it with black pixels.\n      const ctx = createCanvasFunction(crop_width, crop_height).getContext('2d');\n      let sourceX = 0;\n      let sourceY = 0;\n      let destX = 0;\n      let destY = 0;\n      if (width_offset >= 0) {\n        sourceX = width_offset;\n      } else {\n        destX = -width_offset;\n      }\n      if (height_offset >= 0) {\n        sourceY = height_offset;\n      } else {\n        destY = -height_offset;\n      }\n\n      // Draw image to context, cropping in the process\n      ctx.drawImage(canvas, sourceX, sourceY, crop_width, crop_height, destX, destY, crop_width, crop_height);\n\n      // Create image from the resized data\n      let resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);\n\n      // Convert back so that image has the same number of channels as before\n      return resizedImage.convert(numChannels);\n    } else {\n      // Create sharp image from raw data\n      let img = sharp(this.data, {\n        raw: {\n          width: this.width,\n          height: this.height,\n          channels: this.channels\n        }\n      });\n      if (width_offset >= 0 && height_offset >= 0) {\n        // Cropped image lies entirely within the original image\n        img = img.extract({\n          left: Math.floor(width_offset),\n          top: Math.floor(height_offset),\n          width: crop_width,\n          height: crop_height\n        });\n      } else if (width_offset <= 0 && height_offset <= 0) {\n        // Cropped image lies entirely outside the original image,\n        // so we add padding\n        let top = Math.floor(-height_offset);\n        let left = Math.floor(-width_offset);\n        img = img.extend({\n          top: top,\n          left: left,\n          // Ensures the resulting image has the desired dimensions\n          right: crop_width - this.width - left,\n          bottom: crop_height - this.height - top\n        });\n      } else {\n        // Cropped image lies partially outside the original image.\n        // We first pad, then crop.\n\n        let y_padding = [0, 0];\n        let y_extract = 0;\n        if (height_offset < 0) {\n          y_padding[0] = Math.floor(-height_offset);\n          y_padding[1] = crop_height - this.height - y_padding[0];\n        } else {\n          y_extract = Math.floor(height_offset);\n        }\n        let x_padding = [0, 0];\n        let x_extract = 0;\n        if (width_offset < 0) {\n          x_padding[0] = Math.floor(-width_offset);\n          x_padding[1] = crop_width - this.width - x_padding[0];\n        } else {\n          x_extract = Math.floor(width_offset);\n        }\n        img = img.extend({\n          top: y_padding[0],\n          bottom: y_padding[1],\n          left: x_padding[0],\n          right: x_padding[1]\n        }).extract({\n          left: x_extract,\n          top: y_extract,\n          width: crop_width,\n          height: crop_height\n        });\n      }\n      return await loadImageFunction(img);\n    }\n  }\n  toCanvas() {\n    // Clone, and convert data to RGBA before drawing to canvas.\n    // This is because the canvas API only supports RGBA\n    let cloned = this.clone().rgba();\n\n    // Create canvas object for the cloned image\n    let clonedCanvas = createCanvasFunction(cloned.width, cloned.height);\n\n    // Draw image to context\n    let data = new ImageDataClass(cloned.data, cloned.width, cloned.height);\n    clonedCanvas.getContext('2d').putImageData(data, 0, 0);\n    return clonedCanvas;\n  }\n\n  /**\n   * Helper method to update the image data.\n   * @param {Uint8ClampedArray} data The new image data.\n   * @param {number} width The new width of the image.\n   * @param {number} height The new height of the image.\n   * @param {1|2|3|4} channels The new number of channels of the image.\n   */\n  _update(data, width, height) {\n    let channels = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    this.data = data;\n    this.width = width;\n    this.height = height;\n    if (channels !== null) {\n      this.channels = channels;\n    }\n    return this;\n  }\n\n  /**\n   * Clone the image\n   * @returns {RawImage} The cloned image\n   */\n  clone() {\n    return new RawImage(this.data.slice(), this.width, this.height, this.channels);\n  }\n\n  /**\n   * Helper method for converting image to have a certain number of channels\n   * @param {number} numChannels The number of channels. Must be 1, 3, or 4.\n   * @returns {RawImage} `this` to support chaining.\n   */\n  convert(numChannels) {\n    if (this.channels === numChannels) return this; // Already correct number of channels\n\n    switch (numChannels) {\n      case 1:\n        this.grayscale();\n        break;\n      case 3:\n        this.rgb();\n        break;\n      case 4:\n        this.rgba();\n        break;\n      default:\n        throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n    }\n    return this;\n  }\n\n  /**\n   * Save the image to the given path. This method is only available in environments with access to the FileSystem.\n   * @param {string|Buffer|URL} path The path to save the image to.\n   * @param {string} [mime='image/png'] The mime type of the image.\n   */\n  save(path) {\n    let mime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'image/png';\n    if (!env.useFS) {\n      throw new Error('Unable to save the image because filesystem is disabled in this environment.');\n    }\n    let canvas = this.toCanvas();\n    const buffer = canvas.toBuffer(mime);\n    fs.writeFileSync(path, buffer);\n  }\n}","map":{"version":3,"names":["fs","isString","getFile","env","sharp","BROWSER_ENV","self","createCanvasFunction","ImageDataClass","loadImageFunction","width","height","OffscreenCanvas","Error","createImageBitmap","ImageData","img","data","info","raw","toBuffer","resolveWithObject","RawImage","Uint8ClampedArray","channels","RESAMPLING_MAPPING","constructor","_update","read","input","URL","fromURL","url","response","blob","fromBlob","ctx","getContext","drawImage","getImageData","arrayBuffer","grayscale","newData","i","offset","length","red","green","blue","Math","round","rgb","rgba","resize","resample","arguments","undefined","resampleMethod","numChannels","canvas","toCanvas","resizedImage","convert","console","warn","affine","interpolator","fit","kernel","pad","_ref","left","right","top","bottom","max","newWidth","newHeight","paddedImage","extend","center_crop","crop_width","crop_height","width_offset","height_offset","sourceX","sourceY","destX","destY","extract","floor","y_padding","y_extract","x_padding","x_extract","cloned","clone","clonedCanvas","putImageData","slice","save","path","mime","useFS","buffer","writeFileSync"],"sources":["/Users/phreetech13/Desktop/RealTimeAudioToText/node_modules/@xenova/transformers/src/utils/image.js"],"sourcesContent":["\n/**\n * @file Helper module for image processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/image\n */\n\nimport fs from 'fs';\nimport { isString } from './core.js';\nimport { getFile } from './hub.js';\nimport { env } from '../env.js';\n\n// Will be empty (or not used) if running in browser or web-worker\nimport sharp from 'sharp';\n\nconst BROWSER_ENV = typeof self !== 'undefined';\n\nlet createCanvasFunction;\nlet ImageDataClass;\nlet loadImageFunction;\nif (BROWSER_ENV) {\n    // Running in browser or web-worker\n    createCanvasFunction = (/** @type {number} */ width, /** @type {number} */ height) => {\n        if (!self.OffscreenCanvas) {\n            throw new Error('OffscreenCanvas not supported by this browser.');\n        }\n        return new self.OffscreenCanvas(width, height)\n    };\n    loadImageFunction = self.createImageBitmap;\n    ImageDataClass = self.ImageData;\n\n} else if (sharp) {\n    // Running in Node.js, electron, or other non-browser environment\n\n    loadImageFunction = async (/**@type {sharp.Sharp}*/img) => {\n        let { data, info } = await img.raw().toBuffer({ resolveWithObject: true });\n        return new RawImage(new Uint8ClampedArray(data), info.width, info.height, info.channels);\n    }\n\n} else {\n    throw new Error('Unable to load image processing library.');\n}\n\n\n// Defined here: https://github.com/python-pillow/Pillow/blob/a405e8406b83f8bfb8916e93971edc7407b8b1ff/src/libImaging/Imaging.h#L262-L268\nconst RESAMPLING_MAPPING = {\n    0: 'nearest',\n    1: 'lanczos',\n    2: 'bilinear',\n    3: 'bicubic',\n    4: 'box',\n    5: 'hamming',\n}\n\nexport class RawImage {\n\n    /**\n     * Create a new `RawImage` object.\n     * @param {Uint8ClampedArray} data The pixel data.\n     * @param {number} width The width of the image.\n     * @param {number} height The height of the image.\n     * @param {1|2|3|4} channels The number of channels.\n     */\n    constructor(data, width, height, channels) {\n        this._update(data, width, height, channels);\n    }\n\n    /**\n     * Helper method for reading an image from a variety of input types.\n     * @param {RawImage|string|URL} input \n     * @returns The image object.\n     * \n     * **Example:** Read image from a URL.\n     * ```javascript\n     * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');\n     * // test {\n     * //   \"data\": Uint8ClampedArray [ 25, 25, 25, 19, 19, 19, ... ],\n     * //   \"width\": 800,\n     * //   \"height\": 533,\n     * //   \"channels\": 3\n     * // }\n     * ```\n     */\n    static async read(input) {\n        if (input instanceof RawImage) {\n            return input;\n        } else if (isString(input) || input instanceof URL) {\n            return await this.fromURL(input);\n        } else {\n            throw new Error(`Unsupported input type: ${typeof input}`);\n        }\n    }\n\n\n    /**\n     * Read an image from a URL or file path.\n     * @param {string|URL} url The URL or file path to read the image from.\n     * @returns {Promise<RawImage>} The image object.\n     */\n    static async fromURL(url) {\n        let response = await getFile(url);\n        let blob = await response.blob();\n        return this.fromBlob(blob);\n    }\n\n    /**\n     * Helper method to create a new Image from a blob.\n     * @param {Blob} blob The blob to read the image from.\n     * @returns {Promise<RawImage>} The image object.\n     */\n    static async fromBlob(blob) {\n        if (BROWSER_ENV) {\n            // Running in environment with canvas\n            let img = await loadImageFunction(blob);\n\n            const ctx = createCanvasFunction(img.width, img.height).getContext('2d');\n\n            // Draw image to context\n            ctx.drawImage(img, 0, 0);\n\n            return new this(ctx.getImageData(0, 0, img.width, img.height).data, img.width, img.height, 4);\n\n        } else {\n            // Use sharp.js to read (and possible resize) the image.\n            let img = sharp(await blob.arrayBuffer());\n\n            return await loadImageFunction(img);\n        }\n    }\n\n    /**\n     * Convert the image to grayscale format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    grayscale() {\n        if (this.channels === 1) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 3);\n        switch (this.channels) {\n            case 3: // rgb to grayscale\n            case 4: // rgba to grayscale\n                for (let i = 0, offset = 0; i < this.data.length; i += this.channels) {\n                    const red = this.data[i];\n                    const green = this.data[i + 1];\n                    const blue = this.data[i + 2];\n\n                    newData[offset++] = Math.round(0.2989 * red + 0.5870 * green + 0.1140 * blue);\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this._update(newData, this.width, this.height, 1);\n    }\n\n    /**\n     * Convert the image to RGB format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    rgb() {\n        if (this.channels === 3) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 3);\n\n        switch (this.channels) {\n            case 1: // grayscale to rgb\n                for (let i = 0, offset = 0; i < this.data.length; ++i) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                }\n                break;\n            case 4: // rgba to rgb\n                for (let i = 0, offset = 0; i < this.data.length; i += 4) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i + 1];\n                    newData[offset++] = this.data[i + 2];\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this._update(newData, this.width, this.height, 3);\n\n    }\n\n    /**\n     * Convert the image to RGBA format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    rgba() {\n        if (this.channels === 4) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 4);\n\n        switch (this.channels) {\n            case 1: // grayscale to rgba\n                for (let i = 0, offset = 0; i < this.data.length; ++i) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = 255;\n                }\n                break;\n            case 3: // rgb to rgba\n                for (let i = 0, offset = 0; i < this.data.length; i += 3) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i + 1];\n                    newData[offset++] = this.data[i + 2];\n                    newData[offset++] = 255;\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n\n        return this._update(newData, this.width, this.height, 4);\n    }\n\n    /**\n     * Resize the image to the given dimensions. This method uses the canvas API to perform the resizing.\n     * @param {number} width The width of the new image.\n     * @param {number} height The height of the new image.\n     * @param {Object} options Additional options for resizing.\n     * @param {0|1|2|3|4|5|string} [options.resample] The resampling method to use.\n     * @returns {Promise<RawImage>} `this` to support chaining.\n     */\n    async resize(width, height, {\n        resample = 2,\n    } = {}) {\n\n        // Ensure resample method is a string\n        let resampleMethod = RESAMPLING_MAPPING[resample] ?? resample;\n\n        if (BROWSER_ENV) {\n            // TODO use `resample` in browser environment\n\n            // Store number of channels before resizing\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            // Actually perform resizing using the canvas API\n            const ctx = createCanvasFunction(width, height).getContext('2d');\n\n            // Draw image to context, resizing in the process\n            ctx.drawImage(canvas, 0, 0, width, height);\n\n            // Create image from the resized data\n            let resizedImage = new RawImage(ctx.getImageData(0, 0, width, height).data, width, height, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return resizedImage.convert(numChannels);\n\n        } else {\n            // Create sharp image from raw data, and resize\n            let img = sharp(this.data, {\n                raw: {\n                    width: this.width,\n                    height: this.height,\n                    channels: this.channels\n                }\n            });\n\n            switch (resampleMethod) {\n                case 'box':\n                case 'hamming':\n                    if (resampleMethod === 'box' || resampleMethod === 'hamming') {\n                        console.warn(`Resampling method ${resampleMethod} is not yet supported. Using bilinear instead.`);\n                        resampleMethod = 'bilinear';\n                    }\n\n                case 'nearest':\n                case 'bilinear':\n                case 'bicubic':\n                    // Perform resizing using affine transform. \n                    // This matches how the python Pillow library does it.\n                    img = img.affine([width / this.width, 0, 0, height / this.height], {\n                        interpolator: resampleMethod\n                    });\n                    break;\n\n                case 'lanczos':\n                    // https://github.com/python-pillow/Pillow/discussions/5519\n                    // https://github.com/lovell/sharp/blob/main/docs/api-resize.md\n                    img = img.resize({\n                        width, height,\n                        fit: 'fill',\n                        kernel: 'lanczos3', // PIL Lanczos uses a kernel size of 3 \n                    });\n                    break;\n\n                default:\n                    throw new Error(`Resampling method ${resampleMethod} is not supported.`);\n            }\n\n            return await loadImageFunction(img);\n        }\n\n    }\n\n    async pad([left, right, top, bottom]) {\n        left = Math.max(left, 0);\n        right = Math.max(right, 0);\n        top = Math.max(top, 0);\n        bottom = Math.max(bottom, 0);\n\n        if (left === 0 && right === 0 && top === 0 && bottom === 0) {\n            // No padding needed\n            return this;\n        }\n\n        if (BROWSER_ENV) {\n            // Store number of channels before padding\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            let newWidth = this.width + left + right;\n            let newHeight = this.height + top + bottom;\n\n            // Create a new canvas of the desired size.\n            const ctx = createCanvasFunction(newWidth, newHeight).getContext('2d');\n\n            // Draw image to context, padding in the process\n            ctx.drawImage(canvas,\n                0, 0, this.width, this.height,\n                left, top, newWidth, newHeight\n            );\n\n            // Create image from the padded data\n            let paddedImage = new RawImage(\n                ctx.getImageData(0, 0, newWidth, newHeight).data,\n                newWidth, newHeight, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return paddedImage.convert(numChannels);\n\n        } else {\n            let img = sharp(this.data, {\n                raw: {\n                    width: this.width,\n                    height: this.height,\n                    channels: this.channels\n                }\n            }).extend({ left, right, top, bottom });\n            return await loadImageFunction(img);\n        }\n    }\n\n    async center_crop(crop_width, crop_height) {\n        // If the image is already the desired size, return it\n        if (this.width === crop_width && this.height === crop_height) {\n            return this;\n        }\n\n        // Determine bounds of the image in the new canvas\n        let width_offset = (this.width - crop_width) / 2;\n        let height_offset = (this.height - crop_height) / 2;\n\n\n        if (BROWSER_ENV) {\n            // Store number of channels before resizing\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            // Create a new canvas of the desired size. This is needed since if the \n            // image is too small, we need to pad it with black pixels.\n            const ctx = createCanvasFunction(crop_width, crop_height).getContext('2d');\n\n            let sourceX = 0;\n            let sourceY = 0;\n            let destX = 0;\n            let destY = 0;\n\n            if (width_offset >= 0) {\n                sourceX = width_offset;\n            } else {\n                destX = -width_offset;\n            }\n\n            if (height_offset >= 0) {\n                sourceY = height_offset;\n            } else {\n                destY = -height_offset;\n            }\n\n            // Draw image to context, cropping in the process\n            ctx.drawImage(canvas,\n                sourceX, sourceY, crop_width, crop_height,\n                destX, destY, crop_width, crop_height\n            );\n\n            // Create image from the resized data\n            let resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return resizedImage.convert(numChannels);\n\n        } else {\n            // Create sharp image from raw data\n            let img = sharp(this.data, {\n                raw: {\n                    width: this.width,\n                    height: this.height,\n                    channels: this.channels\n                }\n            });\n\n            if (width_offset >= 0 && height_offset >= 0) {\n                // Cropped image lies entirely within the original image\n                img = img.extract({\n                    left: Math.floor(width_offset),\n                    top: Math.floor(height_offset),\n                    width: crop_width,\n                    height: crop_height,\n                })\n            } else if (width_offset <= 0 && height_offset <= 0) {\n                // Cropped image lies entirely outside the original image,\n                // so we add padding\n                let top = Math.floor(-height_offset);\n                let left = Math.floor(-width_offset);\n                img = img.extend({\n                    top: top,\n                    left: left,\n\n                    // Ensures the resulting image has the desired dimensions\n                    right: crop_width - this.width - left,\n                    bottom: crop_height - this.height - top,\n                });\n            } else {\n                // Cropped image lies partially outside the original image.\n                // We first pad, then crop.\n\n                let y_padding = [0, 0];\n                let y_extract = 0;\n                if (height_offset < 0) {\n                    y_padding[0] = Math.floor(-height_offset);\n                    y_padding[1] = crop_height - this.height - y_padding[0];\n                } else {\n                    y_extract = Math.floor(height_offset);\n                }\n\n                let x_padding = [0, 0];\n                let x_extract = 0;\n                if (width_offset < 0) {\n                    x_padding[0] = Math.floor(-width_offset);\n                    x_padding[1] = crop_width - this.width - x_padding[0];\n                } else {\n                    x_extract = Math.floor(width_offset);\n                }\n\n                img = img.extend({\n                    top: y_padding[0],\n                    bottom: y_padding[1],\n                    left: x_padding[0],\n                    right: x_padding[1],\n                }).extract({\n                    left: x_extract,\n                    top: y_extract,\n                    width: crop_width,\n                    height: crop_height,\n                })\n            }\n\n            return await loadImageFunction(img);\n        }\n    }\n\n    toCanvas() {\n        // Clone, and convert data to RGBA before drawing to canvas.\n        // This is because the canvas API only supports RGBA\n        let cloned = this.clone().rgba();\n\n        // Create canvas object for the cloned image\n        let clonedCanvas = createCanvasFunction(cloned.width, cloned.height);\n\n        // Draw image to context\n        let data = new ImageDataClass(cloned.data, cloned.width, cloned.height);\n        clonedCanvas.getContext('2d').putImageData(data, 0, 0);\n\n        return clonedCanvas;\n    }\n\n    /**\n     * Helper method to update the image data.\n     * @param {Uint8ClampedArray} data The new image data.\n     * @param {number} width The new width of the image.\n     * @param {number} height The new height of the image.\n     * @param {1|2|3|4} channels The new number of channels of the image.\n     */\n    _update(data, width, height, channels = null) {\n        this.data = data;\n        this.width = width;\n        this.height = height;\n        if (channels !== null) {\n            this.channels = channels;\n        }\n        return this;\n    }\n\n    /**\n     * Clone the image\n     * @returns {RawImage} The cloned image\n     */\n    clone() {\n        return new RawImage(this.data.slice(), this.width, this.height, this.channels);\n    }\n\n    /**\n     * Helper method for converting image to have a certain number of channels\n     * @param {number} numChannels The number of channels. Must be 1, 3, or 4.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    convert(numChannels) {\n        if (this.channels === numChannels) return this; // Already correct number of channels\n\n        switch (numChannels) {\n            case 1:\n                this.grayscale();\n                break;\n            case 3:\n                this.rgb();\n                break;\n            case 4:\n                this.rgba();\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this;\n    }\n\n    /**\n     * Save the image to the given path. This method is only available in environments with access to the FileSystem.\n     * @param {string|Buffer|URL} path The path to save the image to.\n     * @param {string} [mime='image/png'] The mime type of the image.\n     */\n    save(path, mime = 'image/png') {\n        if (!env.useFS) {\n            throw new Error('Unable to save the image because filesystem is disabled in this environment.')\n        }\n\n        let canvas = this.toCanvas();\n        const buffer = canvas.toBuffer(mime);\n        fs.writeFileSync(path, buffer);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}